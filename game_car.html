<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>IMU Game - Endless Runner (Car Version)</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #score {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 24px;
      z-index: 1;
    }
    #highScore {
      position: absolute;
      top: 40px;
      left: 10px;
      color: gold;
      font-size: 20px;
      z-index: 1;
    }
    #wsMessage {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 16px;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      z-index: 1;
      max-width: 80%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: red;
      font-size: 48px;
      display: none;
      z-index: 1;
    }
    /* Updated countdown style for better visibility */
    #countdown {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 72px;
      display: none;
      z-index: 1000;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 20px 40px;
      border-radius: 10px;
    }
    #imuPanel {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.5);
      color: white;
      padding: 10px;
      z-index: 1;
    }
    #startGameBtn {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 18px;
      z-index: 1;
    }
    #restartGameBtn {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 18px;
      z-index: 1;
      display: none;
    }
    /* New elements for penalty display and time control */
    #scoreChange {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: red;
      font-size: 50px;
      z-index: 10;
      display: none;
    }
    #stopwatch {
        position: absolute;
        top: 10%;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        font-size: 40px;
        font-weight: bold;
        z-index: 10;
        text-align: center;
    }
    #timePanel {
      position: absolute;
      top: 50px;
      right: 10px;
      background: rgba(0,0,0,0.5);
      color: white;
      padding: 10px;
      z-index: 1;
    }
  </style>
  <!-- Include three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
  <audio id="audio"></audio>
  <div id="score">Score: 0</div>
  <div id="highScore">High Score: 0</div>
  <div id="gameOver">Game Over</div>
  <div id="countdown"></div>
  <div id="scoreChange"></div>
  <div id="stopwatch">Time: 0:00</div>
  <div id="timePanel">
    <label for="gameTimeSelect">Select Game Duration:</label>
    <select id="gameTimeSelect">
      <option value="30000">30 Seconds</option>
      <option value="60000">1 Minute</option>
      <option value="120000">2 Minutes</option>
      <option value="180000">3 Minutes</option>
    </select>
  </div>
 
  <div id="imuPanel">
    <label for="imuIdInput">Enter IMU ID:</label>
    <input type="text" id="imuIdInput" placeholder="e.g., my_imu_id" />
    <button id="connectBtn">Connect</button>
  </div>
  <button id="startGameBtn">Start Game</button>
  <button id="restartGameBtn">Restart</button>
  
  <script>
    // ----------------------
    // Global Game Variables
    // ----------------------
    let scene, camera, renderer;
    let player;                // The player's car (Group object)
    let obstacles = [];        // Array of obstacle (parked) cars
    let coins = [];            // Array of collectible coins
    let roadSegments = [];     // Array of segments (road, water, bridge, etc.)
    let gameOver = false;
    let score = 0;
    let coinBonus = 0;         // Bonus score from coins
    let highScore = 0;         // Track the user's best score across attempts
    let gameDuration = 0;
    let gameStartTime = 0;
    let penalty = 0;
    let effectiveScore = 0;
    let bridgePenaltyActive = false;
    
    // Global variable for player name
    let playerName = "";

    // Movement / World logic
    const basePlayerSpeed = 0.3; // Base forward movement speed
    var playerSpeed = basePlayerSpeed;      
    var speedPercent = 0.0;
    const lateralSpeedFactor = 0.05; // Factor to convert tilt (in degrees) to lateral movement

    const forwardTiltLowerBound = 10.0; // Absolute values less than this cause the car to move at full speed
    const forwardTiltUpperBound = 20.0; // Absolute values higher than this will cause the car's movement to stop

    let currentTilt = { x: 0, y: 0, z: 0 }; // Latest IMU tilt values (in radians)
    let animationId; // To store the requestAnimationFrame ID

    // Infinite spawning logic
    let spawnZ = 0;            // How far we've spawned obstacles/segments
    const spawnDistance = 400; // Lookahead distance for spawning chunks earlier

    // Obstacle and road settings
    const obstacleSpacing = 20;
    const roadWidth = 20;      // Overall road width
    const minCarSeparation = 2.0; 
    const sideMargin = 1.0;

    // Audio
    const audio = document.getElementById("audio");

    // List of audio file options
    const audioFiles = [
        "audio/BackOnTrack.ogg",
        "audio/BaseAfterBase.ogg",
        "audio/BlastProcessing.ogg",
        "audio/CantLetGo.ogg",
        "audio/Clubstep.ogg",
        "audio/Clutterfunk.ogg",
        "audio/Cycles.ogg",
        "audio/Deadlocked.ogg",
        "audio/DryOut.ogg",
        "audio/Electrodynamix.ogg",
        "audio/Electroman.ogg",
        "audio/GeometricalDominator.ogg",
        "audio/HexagonForce.ogg",
        "audio/Jumper.ogg",
        "audio/menuLoop.ogg",
        "audio/Polargeist.ogg",
        "audio/secretLoop.ogg",
        "audio/StayInsideMe.ogg",
        "audio/StereoMadness.ogg",
        "audio/TheoryOfEverything.ogg",
        "audio/TheoryOfEverything2.ogg",
        "audio/TimeMachine.ogg",
        "audio/xStep.ogg"
    ];


    function playRandomAudio() {
        // Select a random file from the array
        const randomIndex = Math.floor(Math.random() * audioFiles.length);
        const selectedFile = audioFiles[randomIndex];

        // Set the selected file as the audio source
        audio.src = selectedFile;
        audio.volume = 0.4;
        audio.play();

        console.log(`Playing: ${selectedFile}`);
    }

    function stopAudio() {
        audio.pause();
        audio.currentTime = 0; // Reset playback
    }

    function changeSpeed(value) {
        audio.playbackRate = value;
        console.log(`Playback speed: ${value}`);
    }

    // Global flag to ensure no two consecutive bridge segments.
    let lastSegmentBridge = false;

    // ----------------------
    // Create a simple cartoon car for the player, oriented along +Z
    // ----------------------
    function createCartoonCar(color = 0x0000ff) {
      const carGroup = new THREE.Group();
      const bodyGeometry = new THREE.BoxGeometry(1, 0.5, 2);
      const bodyMaterial = new THREE.MeshPhongMaterial({ color });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.set(0, 0.25, 0);
      carGroup.add(body);
      const cabinGeometry = new THREE.BoxGeometry(1, 0.5, 1);
      const cabinMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
      const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
      cabin.position.set(0, 0.75, 0);
      carGroup.add(cabin);
      const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.2, 12);
      const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
      const frontLeftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
      frontLeftWheel.rotation.x = Math.PI / 2; 
      frontLeftWheel.position.set(0.4, 0, 0.7);
      carGroup.add(frontLeftWheel);
      const frontRightWheel = frontLeftWheel.clone();
      frontRightWheel.position.set(-0.4, 0, 0.7);
      carGroup.add(frontRightWheel);
      const backLeftWheel = frontLeftWheel.clone();
      backLeftWheel.position.set(0.4, 0, -0.7);
      carGroup.add(backLeftWheel);
      const backRightWheel = frontLeftWheel.clone();
      backRightWheel.position.set(-0.4, 0, -0.7);
      carGroup.add(backRightWheel);
      return carGroup;
    }

    // ----------------------
    // Create a parked car obstacle, also oriented along +Z
    // ----------------------
    function createParkedCar(color = 0xff0000) {
      const carGroup = new THREE.Group();
      const bodyGeometry = new THREE.BoxGeometry(1, 0.5, 2);
      const bodyMaterial = new THREE.MeshPhongMaterial({ color });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.set(0, 0.25, 0);
      carGroup.add(body);
      const cabinGeometry = new THREE.BoxGeometry(1, 0.5, 1);
      const cabinMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });
      const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
      cabin.position.set(0, 0.75, 0);
      carGroup.add(cabin);
      const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.2, 12);
      const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
      const frontLeftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
      frontLeftWheel.rotation.x = Math.PI / 2;
      frontLeftWheel.position.set(0.4, 0, 0.7);
      carGroup.add(frontLeftWheel);
      const frontRightWheel = frontLeftWheel.clone();
      frontRightWheel.position.set(-0.4, 0, 0.7);
      carGroup.add(frontRightWheel);
      const backLeftWheel = frontLeftWheel.clone();
      backLeftWheel.position.set(0.4, 0, -0.7);
      carGroup.add(backLeftWheel);
      const backRightWheel = frontLeftWheel.clone();
      backRightWheel.position.set(-0.4, 0, -0.7);
      carGroup.add(backRightWheel);
      return carGroup;
    }
    
    // ----------------------
    // Create a coin collectible
    // ----------------------
    function createCoin() {
      const coinGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 32);
      const coinMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00 });
      const coin = new THREE.Mesh(coinGeometry, coinMaterial);
      coin.rotation.x = Math.PI / 2;
      return coin;
    }

    // ----------------------
    // Utility Functions for Penalty and Animation
    // ----------------------
    function showScorePenalty(text) {
      const el = document.getElementById("scoreChange");
      el.textContent = text;
      el.style.display = "block";
      el.style.color = "red";
      let startTime = performance.now();
      let fadeInterval = setInterval(() => {
        let elapsed = performance.now() - startTime;
        if (elapsed > 1000) {
          clearInterval(fadeInterval);
          el.style.display = "none";
        } else {
          let opacity = 1 - (elapsed / 1000);
          el.style.opacity = opacity;
        }
      }, 50);
    }

    function showScoreIncrease(text) {
      const el = document.getElementById("scoreChange");
      el.textContent = text;
      el.style.display = "block";
      el.style.color = "yellow";
      let startTime = performance.now();
      let fadeInterval = setInterval(() => {
        let elapsed = performance.now() - startTime;
        if (elapsed > 1000) {
          clearInterval(fadeInterval);
          el.style.display = "none";
        } else {
          let opacity = 1 - (elapsed / 1000);
          el.style.opacity = opacity;
        }
      }, 50);
    }

    function animateCrash(object) {
      const originalPos = object.position.clone();
      const explosionPos = object.position.clone();
      const explosionSound = new Audio('audio/explosion.mp3');
      explosionSound.currentTime = 0; // Reset time to allow quick replay

      explosionSound.play();
      console.log(explosionPos);
      explosionPos.z -= 1;
      explosionPos.y += 1;

      // Load the explosion GIF texture
      const textureLoader = new THREE.TextureLoader();
      textureLoader.load('explosion.gif', function(texture) {
        // Create a sprite material using the explosion texture
        const spriteMaterial = new THREE.SpriteMaterial({
          map: texture,
          transparent: true
        });
        // Create the explosion sprite
        const explosionSprite = new THREE.Sprite(spriteMaterial);
        // Position it at the location of the crash
        explosionSprite.position.copy(explosionPos);
        // Adjust the scale to control the size of the explosion
        explosionSprite.scale.set(3, 3, 1);
        // Add the sprite to the scene
        scene.add(explosionSprite);

        // Remove the explosion effect after 1 second
        setTimeout(() => {
          scene.remove(explosionSprite);
          spriteMaterial.dispose();
          texture.dispose();
        }, 1000);
      });

  // Shake the object to simulate the crash impact
  const shakeDuration = 300;
  const startTime = performance.now();
  let shakeInterval = setInterval(() => {
    let elapsed = performance.now() - startTime;
    if (elapsed > shakeDuration) {
      clearInterval(shakeInterval);
      object.position.copy(originalPos);
    } else {
      object.position.x = originalPos.x + (Math.random() - 0.5) * 0.3;
      object.position.z = originalPos.z + (Math.random() - 0.5) * 0.3;
    }
  }, 30);
}

    function rewindPlayerBehindBridge(segData) {
      const behindDist = 15;
      let behindZ = segData.zStart - behindDist;
      if (behindZ < 0) behindZ = 0;
      player.position.x = (segData.bridgeXMin + segData.bridgeXMax) / 2;
      player.position.z = behindZ;
    }

    function updateStopwatch() {
      let elapsedMs = performance.now() - gameStartTime;
      let totalSec = Math.floor(elapsedMs / 1000);
        let minutes = Math.floor(totalSec / 60);
        let seconds = totalSec % 60;
        let secondsStr = (seconds < 10) ? ("0" + seconds) : seconds;
        document.getElementById("stopwatch").textContent = "Time: " + minutes + ":" + secondsStr;
    }

    // ----------------------
    // Segment definitions.
    // Each segment type defines a default length and a spawn() method that creates its objects.
    // ----------------------
    const segmentTypes = {
      straightRoad: {
        length: 50,
        spawn: function(zStart, length) {
          const geometry = new THREE.PlaneGeometry(roadWidth, length);
          const material = new THREE.MeshPhongMaterial({ color: 0x444444 });
          const road = new THREE.Mesh(geometry, material);
          road.rotation.x = -Math.PI / 2;
          road.position.z = zStart + length / 2;
          road.userData = {
            segmentType: "straightRoad",
            zStart: zStart,
            zEnd: zStart + length,
          }
          scene.add(road);
          roadSegments.push(road);

          const dashLength = 2, dashSpace = 4;
          const dashCount = Math.floor(length / dashSpace);
          for (let i = 0; i < dashCount; i++) {
            const dashZ = zStart + i * dashSpace + dashSpace / 2;
            const dashGeom = new THREE.PlaneGeometry(0.2, dashLength);
            const dashMat = new THREE.MeshPhongMaterial({ color: 0xffff00 });
            const dash = new THREE.Mesh(dashGeom, dashMat);
            dash.rotation.x = -Math.PI / 2;
            dash.position.set(0, 0.01, dashZ);
            scene.add(dash);
            roadSegments.push(dash);
          }

          const leftLineGeom = new THREE.PlaneGeometry(0.1, length);
          const leftLineMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
          const leftLine = new THREE.Mesh(leftLineGeom, leftLineMat);
          leftLine.rotation.x = -Math.PI / 2;
          leftLine.position.set(-roadWidth / 2, 0.01, zStart + length / 2);
          scene.add(leftLine);
          roadSegments.push(leftLine);
          const rightLine = leftLine.clone();
          rightLine.position.set(roadWidth / 2, 0.01, zStart + length / 2);
          scene.add(rightLine);
          roadSegments.push(rightLine);

          for (let z = zStart + obstacleSpacing; z < zStart + length; z += obstacleSpacing) {
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffffff, 0xffa500];
            const obstacleCount = 2 + Math.floor(Math.random() * 2);
            const chosenXPositions = [];
            for (let i = 0; i < obstacleCount; i++) {
              let attemptCount = 0, foundSpot = false, xPos = 0;
              while (attemptCount < 10 && !foundSpot) {
                const minX = -roadWidth / 2 + sideMargin;
                const maxX = roadWidth / 2 - sideMargin;
                xPos = Math.random() * (maxX - minX) + minX;
                let tooClose = false;
                for (let px of chosenXPositions) {
                  if (Math.abs(xPos - px) < minCarSeparation) {
                    tooClose = true;
                    break;
                  }
                }
                if (!tooClose) {
                  foundSpot = true;
                  chosenXPositions.push(xPos);
                }
                attemptCount++;
              }
              if (foundSpot) {
                const randColor = colors[Math.floor(Math.random() * colors.length)];
                const parkedCar = createParkedCar(randColor);
                parkedCar.position.set(xPos, 0, z);
                scene.add(parkedCar);
                obstacles.push(parkedCar);
              }
            }
          }
        },
        handleCollisions(data) {
          if (player.position.x < -roadWidth / 2) player.position.x = -roadWidth / 2;
          if (player.position.x > roadWidth / 2) player.position.x = roadWidth / 2;
        }
      },
      curvedRoad: {
        length: 100,
        spawn: function(zStart, length) {
          const wavePeriod = 1;
          const waveWidth = 1;
          const numPoints = 50;
          const leftCurvePoints = [];
          const rightCurvePoints = [];
          const middleCurvePoints = [];

          for (let i = 0; i < numPoints; i++) {
            const t = i / (numPoints - 1);
            const z = zStart + t * length;
            const offsetX = (waveWidth * roadWidth * 0.5) * Math.sin(t * wavePeriod * 2 * Math.PI) - (waveWidth * roadWidth * 0.5);
            const y = 0.02;
            leftCurvePoints.push(new THREE.Vector3(offsetX, y, z));
            rightCurvePoints.push(new THREE.Vector3(offsetX + roadWidth, y, z));
            middleCurvePoints.push(new THREE.Vector3(offsetX + roadWidth * 0.5, y, z));
          }

          const roadGeometry = new THREE.BufferGeometry();
          const positions = [];
          for (let i = 0; i < numPoints - 1; i++) {
            const pA = leftCurvePoints[i];
            const pB = rightCurvePoints[i];
            const pC = leftCurvePoints[i+1];
            const pD = rightCurvePoints[i+1];
            positions.push(pA.x, pA.y, pA.z);
            positions.push(pB.x, pB.y, pB.z);
            positions.push(pC.x, pC.y, pC.z);
            positions.push(pB.x, pB.y, pB.z);
            positions.push(pD.x, pD.y, pD.z);
            positions.push(pC.x, pC.y, pC.z);
          }
          const positionAttribute = new THREE.Float32BufferAttribute(positions, 3);
          roadGeometry.setAttribute('position', positionAttribute);
          const roadMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x808080,
            side: THREE.DoubleSide 
          });
          const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
          const leftGeometry = new THREE.BufferGeometry().setFromPoints(leftCurvePoints);
          const rightGeometry = new THREE.BufferGeometry().setFromPoints(rightCurvePoints);
          const middleGeometry = new THREE.BufferGeometry().setFromPoints(middleCurvePoints);
          const dashedMaterial = new THREE.LineDashedMaterial({
            color: 0xffff00,
            dashSize: 2,
            gapSize: 1
          });
          const leftLine = new THREE.Line(leftGeometry, dashedMaterial);
          const rightLine = new THREE.Line(rightGeometry, dashedMaterial);
          const centerDashedMaterial = new THREE.LineDashedMaterial({
            color: 0xffffff,
            dashSize: 2,
            gapSize: 1
          });
          const middleLine = new THREE.Line(middleGeometry, centerDashedMaterial);
          leftLine.computeLineDistances();
          rightLine.computeLineDistances();
          middleLine.computeLineDistances();
          [leftLine, rightLine, middleLine].forEach(line => {
            line.userData = {
              segmentType: 'curvedRoad',
              zStart: zStart,
              zEnd: zStart + length,
              wavePeriod: wavePeriod,
              waveWidth: waveWidth,
              segmentLength: length
            };
          });
          scene.add(roadMesh);
          scene.add(leftLine);
          scene.add(rightLine);
          scene.add(middleLine);
          roadSegments.push(leftLine);
          roadSegments.push(rightLine);
          roadSegments.push(middleLine);
          for (let i = 0; i < numPoints; i++) {
            if (Math.random() < 0.3) {
              const coin = createCoin();
              coin.position.copy(middleCurvePoints[i]);
              coin.position.y += 0.5;
              scene.add(coin);
              coins.push(coin);
            }
          }
        },
        handleCollisions(data) {
          const segLength = data.segmentLength;
          const t = (player.position.z - data.zStart) / segLength;
          const centerX = (data.waveWidth * roadWidth * 0.5) * Math.sin(t * data.wavePeriod * 2 * Math.PI);
          const minX = centerX - (roadWidth / 2);
          const maxX = centerX + (roadWidth / 2);
          if (player.position.x < minX) player.position.x = minX;
          if (player.position.x > maxX) player.position.x = maxX;
        }
      },
      bridge: {
        length: 40,
        spawn: function(zStart, length) {
          const waterGeometry = new THREE.PlaneGeometry(roadWidth * 2, length);
          const waterMaterial = new THREE.MeshPhongMaterial({ color: 0x1e90ff });
          const waterPlane = new THREE.Mesh(waterGeometry, waterMaterial);
          waterPlane.rotation.x = -Math.PI / 2;
          waterPlane.position.z = zStart + length / 2;
          waterPlane.position.y = -0.1;
          scene.add(waterPlane);
          roadSegments.push(waterPlane);
          const bridgeWidth = roadWidth / 5;
          const minX = -roadWidth/2 + bridgeWidth/2;
          const maxX = roadWidth/2 - bridgeWidth/2;
          const bridgeCenterX = Math.random() * (maxX - minX) + minX;
          const bridgeGeometry = new THREE.PlaneGeometry(bridgeWidth, length);
          const bridgeMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
          const bridge = new THREE.Mesh(bridgeGeometry, bridgeMaterial);
          bridge.rotation.x = -Math.PI / 2;
          bridge.position.set(bridgeCenterX, 0.01, zStart + length / 2);
          scene.add(bridge);
          roadSegments.push(bridge);
          bridge.userData = {
            segmentType: "bridge",
            isBridge: true,
            bridgeXMin: bridgeCenterX - bridgeWidth/2,
            bridgeXMax: bridgeCenterX + bridgeWidth/2,
            segmentLength: length,
            zStart: zStart,
            zEnd: zStart + length
          };
        },
        handleCollisions(data) {
          if (player.position.x < data.bridgeXMin || player.position.x > data.bridgeXMax) {
            if (!bridgePenaltyActive) {
              penalty += 20;
              showScorePenalty("-20");
              rewindPlayerBehindBridge(data);
              updateScore();
              bridgePenaltyActive = true;
            } else {
              bridgePenaltyActive = false;
            }
          }
        }
      }
    };

    // ----------------------
    // Unified function to spawn a segment chunk.
    // ----------------------
    function spawnChunk(zStart) {
      let segmentType;
      if (zStart === 0 || lastSegmentBridge) {
        segmentType = "straightRoad";
      } else {
        const rand = Math.random();
        if (rand < 0.2) {
          segmentType = "bridge";
        } else if (rand < 0.5) {
          segmentType = "curvedRoad";
        } else {
          segmentType = "straightRoad";
        }
      }
      let baseLength = segmentTypes[segmentType].length;
      let segmentLength = baseLength * (0.8 + Math.random() * 0.4);
      segmentTypes[segmentType].spawn(zStart, segmentLength);
      lastSegmentBridge = (segmentType === "bridge");
      spawnZ += segmentLength;
    }

    // ----------------------
    // Initialize the three.js scene and game objects
    // ----------------------
    function init() {
      if (renderer && renderer.domElement) {
        document.body.removeChild(renderer.domElement);
      }
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, -10);
      camera.lookAt(0, 0, 0);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.domElement.style.position = "absolute";
      renderer.domElement.style.zIndex = "0";
      document.body.appendChild(renderer.domElement);
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(0, 50, -50);
      scene.add(directionalLight);
      player = createCartoonCar(0x0000ff);
      player.position.set(0, 0, 0);
      scene.add(player);
      spawnZ = 0;
      obstacles = [];
      roadSegments = [];
      coins = [];
      coinBonus = 0;
      penalty = 0;
      score = 0;
      effectiveScore = 0;
      gameOver = false;
      document.getElementById("gameOver").style.display = "none";
      document.getElementById("restartGameBtn").style.display = "none";
      lastSegmentBridge = false;
      spawnChunk(spawnZ);
      window.addEventListener('resize', onWindowResize, false);
      const timeSelect = document.getElementById("gameTimeSelect");
      const chosenMs = parseInt(timeSelect.value, 10);
      gameDuration = chosenMs;
      gameStartTime = performance.now();
      animate();
    }

    // ----------------------
    // Adjust camera and renderer on window resize
    // ----------------------
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ----------------------
    // Check for collisions with obstacles and apply penalty
    // ----------------------
    function checkCollisions() {
      const playerBox = new THREE.Box3().setFromObject(player);
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const obs = obstacles[i];
        const obsBox = new THREE.Box3().setFromObject(obs);
        if (playerBox.intersectsBox(obsBox)) {
          penalty += 10;
          showScorePenalty("-10");
          animateCrash(player);
          updateScore();
          scene.remove(obs);
          obstacles.splice(i, 1);
        }
      }
    }

    // ----------------------
    // Update score based on player's position, coins, and penalty
    // ----------------------
    function updateScore() {
      score = Math.floor(player.position.z) + coinBonus;
      effectiveScore = score - penalty;
      document.getElementById("score").textContent = "Score: " + effectiveScore;
    }

    // ----------------------
    // Update high score if needed
    // ----------------------
    function updateHighScore() {
      if (effectiveScore > highScore) {
        highScore = effectiveScore;
      }
      document.getElementById("highScore").textContent = "High Score: " + highScore;
    }

    // ----------------------
    // The main animation loop
    // ----------------------
    function animate() {
      if (gameOver) return;
      animationId = requestAnimationFrame(animate);

      const absoluteForwardTiltInDegrees = Math.abs(currentTilt.y * (180 / Math.PI));
      if (absoluteForwardTiltInDegrees <= forwardTiltLowerBound) {
        speedPercent = 1.0;
      } else if (absoluteForwardTiltInDegrees > forwardTiltUpperBound) {
        speedPercent = 0.0;
      } else {
        const currDifference = Math.abs(absoluteForwardTiltInDegrees - forwardTiltUpperBound);
        speedPercent = currDifference / (forwardTiltUpperBound - forwardTiltLowerBound);
      }

      changeSpeed(speedPercent);
      playerSpeed = basePlayerSpeed * speedPercent;
      player.position.z += playerSpeed;
      const tiltInDegrees = -currentTilt.x * (180 / Math.PI);
      player.position.x += tiltInDegrees * lateralSpeedFactor * speedPercent;

      camera.position.z = player.position.z - 10;
      camera.position.x = player.position.x;
      camera.lookAt(player.position.x, player.position.y, player.position.z);

      for (let seg of roadSegments) {
        const data = seg.userData;
        if (!data) continue;
        if (player.position.z >= data.zStart && player.position.z <= data.zEnd) {
          if (segmentTypes[data.segmentType] && segmentTypes[data.segmentType].handleCollisions) {
            segmentTypes[data.segmentType].handleCollisions(data);
          }
        }
      }

      // Rotate coins and check for collection
      const playerBox = new THREE.Box3().setFromObject(player);
      for (let i = coins.length - 1; i >= 0; i--) {
        coins[i].rotation.z += 0.05;
        const coinSphere = new THREE.Sphere(coins[i].position, 0.5);
        if (playerBox.intersectsSphere(coinSphere)) {
          showScoreIncrease("+20");
          const coinSound = new Audio('coin.mp3');
          coinSound.currentTime = 0; // Reset time to allow quick replay
          coinSound.play();
          scene.remove(coins[i]);
          coins.splice(i, 1);
          coinBonus += 10;
        }
      }

      if (player.position.z + spawnDistance > spawnZ) {
        spawnChunk(spawnZ);
      }

      checkCollisions();
      updateScore();

      const elapsed = performance.now() - gameStartTime;
      if (elapsed >= gameDuration) {
        endGame();
        return;
      }
      updateStopwatch();
      renderer.render(scene, camera);
    }

    // ----------------------
    // End the game
    // ----------------------
    function endGame() {
      stopAudio();
      gameOver = true;
      cancelAnimationFrame(animationId);
      updateHighScore();
      document.getElementById("gameOver").style.display = "block";
      document.getElementById("restartGameBtn").style.display = "block";
    }

    // ----------------------
    // Restart the game with a countdown
    // ----------------------
    function restartGame() {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      obstacles.forEach(o => scene.remove(o));
      roadSegments.forEach(r => scene.remove(r));
      coins.forEach(c => scene.remove(c));
      scene.remove(player);
      obstacles = [];
      roadSegments = [];
      coins = [];
      coinBonus = 0;
      penalty = 0;
      score = 0;
      effectiveScore = 0;
      document.getElementById("gameOver").style.display = "none";
      document.getElementById("restartGameBtn").style.display = "none";
      startCountdown(init);
    }

    // ----------------------
    // Countdown function before starting the game
    // ----------------------
    function startCountdown(callback) {
      const countdownEl = document.getElementById("countdown");
      let count = 3;
      countdownEl.style.display = "block";
      countdownEl.textContent = count;
      const interval = setInterval(() => {
        count--;
        if (count > 0) {
          countdownEl.textContent = count;
        } else {
          clearInterval(interval);
          countdownEl.textContent = "Go!";
          setTimeout(() => {
            countdownEl.style.display = "none";
            callback();
          }, 500);
        }
      }, 1000);
      playRandomAudio();
    }

    // ----------------------
    // WebSocket (IMU Data) Code
    // ----------------------
    let socket = null;
    let patternTimeout = null;

    document.getElementById("connectBtn").addEventListener("click", function() {
      const imuId = document.getElementById("imuIdInput").value.trim();
      if (!imuId) {
        alert("Please enter an IMU ID.");
        return;
      }
      const wsUrl = `wss://personal-site-oi5a.onrender.com/imu_racing_game/api/ws/imu/${imuId}/broadcast/`;
      console.log("Connecting to", wsUrl);
      if (socket) {
        socket.close();
      }
      socket = new WebSocket(wsUrl);
      socket.onopen = function(event) {
        console.log("Connected to:", wsUrl);
        //document.getElementById("wsMessage").textContent = "Connected to: " + wsUrl;
      };
      socket.onmessage = function(event) {

        // UNCOMMENT THIS FOR DEBUG
        //document.getElementById("wsMessage").textContent = event.data;
        try {
          const msg = JSON.parse(event.data);
          if (msg.data && msg.data.tilt) {
            currentTilt = msg.data.tilt;
            detectGesture(currentTilt);
          }
        } catch (e) {
          console.error("Error parsing message:", e);
        }
      };
      socket.onclose = function(event) {
        console.log("Disconnected from server");
        //document.getElementById("wsMessage").textContent = "Disconnected from server";
      };
      socket.onerror = function(error) {
        console.error("WebSocket error:", error);
        //document.getElementById("wsMessage").textContent = "WebSocket error. Check the console for details.";
      };
    });

    const REQUIRED_DURATION = 3000;
    let yThresholdStartTime = null;

    function detectGesture(tilt) {
      if(document.getElementById("gameOver").style.display == "none"){
        return;
      }
      if (tilt.y > 0.5) {
        if (yThresholdStartTime === null) {
          yThresholdStartTime = Date.now();
          console.log("Y threshold exceeded, starting timer...");
        } else {
          const elapsedTime = Date.now() - yThresholdStartTime;
          console.log(`Y threshold maintained for ${(elapsedTime/1000).toFixed(1)} seconds`);
          if (elapsedTime >= REQUIRED_DURATION) {
            console.log("3 seconds threshold reached! Starting game.");
            document.getElementById("startGameBtn").click();
          }
        }
      } else {
        if (yThresholdStartTime !== null) {
          console.log("Y value dropped below threshold, resetting timer");
          yThresholdStartTime = null;
        }
      }
    }

    // ----------------------
    // Start Game on Button Click (with countdown)
    // ----------------------
    document.getElementById("startGameBtn").addEventListener("click", function() {
      const imuId = document.getElementById("imuIdInput").value.trim();
      if (!imuId) {
        alert("Please enter an IMU ID before starting the game.");
        return;
      }
      if (!socket || socket.readyState !== WebSocket.OPEN) {
        document.getElementById("connectBtn").click();
      }
      this.style.display = "none";
      startCountdown(init);
    });

    document.getElementById("restartGameBtn").addEventListener("click", function() {
      restartGame();
    });
    
    (function() {
      const urlParams = new URLSearchParams(window.location.search);
      const autoImuId = urlParams.get('id');
      if (autoImuId) {
        document.getElementById("imuIdInput").value = autoImuId;
        document.getElementById("connectBtn").click();
      }
    })();
  </script>
</body>
</html>
