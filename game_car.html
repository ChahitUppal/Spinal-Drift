<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>IMU Game - Endless Runner (Car Version)</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #score {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 24px;
      z-index: 1;
    }
    #highScore {
      position: absolute;
      top: 40px;
      left: 10px;
      color: gold;
      font-size: 20px;
      z-index: 1;
    }
    #wsMessage {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 16px;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      z-index: 1;
      max-width: 80%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #ff0000;
      font-size: 60px;
      font-weight: bold;
      display: none;
      z-index: 1;
    }
    /* Updated countdown style for better visibility */
    #countdown {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 72px;
      display: none;
      z-index: 1000;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 20px 40px;
      border-radius: 10px;
    }
    #imuPanel {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.5);
      color: white;
      padding: 10px;
      z-index: 1;
    }
    #startGameBtn {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 18px;
      z-index: 1;
    }
    #restartGameBtn {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 18px;
      z-index: 1;
      display: none;
    }
    /* New elements for penalty display and time control */
    #scoreChange {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: red;
      font-size: 50px;
      z-index: 10;
      display: none;
    }
    #stopwatch {
        position: absolute;
        top: 10%;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        font-size: 40px;
        font-weight: bold;
        z-index: 10;
        text-align: center;
    }
    #timePanel {
      position: absolute;
      top: 50px;
      right: 10px;
      background: rgba(0,0,0,0.5);
      color: white;
      padding: 10px;
      z-index: 1;
    }
  </style>
  <!-- Include three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
  <div id="gameOver">Game Over</div>
  <div id="countdown" style="display: none;"></div>
  <audio id="audio"></audio>
  <button id="restartGameBtn">Restart</button>
  <button id="homeBtn" type="button" style="position: absolute; top: 70px; left: 10px; padding: 5px 10px; font-size: 16px; z-index: 1; display: none;">Home</button>
  <div id="score" style="display:none;">Score: 0</div>
  <div id="scoreChange"></div>
  <div id="highScore" style="display:none;">High Score: 0</div>
  <div id="stopwatch" style="display:none;">Time: 0:00</div>

    <!-- NEW: Menu Screen Overlay -->
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&display=swap" rel="stylesheet">
  <div id="menuScreen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: url('menu_wallpaper.jpg') no-repeat center center; background-size: cover; z-index: 2;">
    <h1 id="gameTitle" style="text-align: center; color: #FFFFFF; font-size: 88px; margin-top: 20%; font-family: 'Playfair Display', cursive, sans-serif;, sans-serif; text-shadow: 0 0 5px #000000, 0 0 10px #000000;">
      Spinal Drift
    </h1>     
    <div style="position: absolute; top: 10px; right: 10px; text-align: right;">
      <div>
        <label for="imuIdInput">Enter IMU ID:</label>
        <input type="text" id="imuIdInput" placeholder="e.g., my_imu_id" />
        <button id="connectBtn" type="button">Connect</button>
      </div>
      <div style="margin-top: 10px;">
        <label for="gameTimeSelect">Select Game Duration:</label>
        <select id="gameTimeSelect">
          <option value="31000">30 Seconds</option>
          <option value="61000">1 Minute</option>
          <option value="121000">2 Minutes</option>
          <option value="181000">3 Minutes</option>
        </select>
      </div>
    </div>
  
    <div style="text-align: center; margin-top: 20px;">
      <label for="vehicleColor">Choose your vehicle color:</label>
      <input type="color" id="vehicleColor" value="#0000ff">
    </div>
    <div style="text-align: center; margin-top: 20px;">
      <button id="howToPlayBtn">How to Play</button>
      <button id="startGameMenuBtn" style="margin-left: 20px;" type="button">Start Game</button>
    </div>
    <!-- How to Play Overlay -->
    <div id="howToPlayOverlay" style="display:none; position: absolute; top: 10%; left: 10%; width:80%; height:80%; background: rgba(0,0,0,0.8); color: white; padding:20px; overflow: auto; z-index:3;">
      <h2>How to Play</h2>
      <ol>
        <li><strong>Steer with Tilt:</strong> Tilt your device to control the carâ€™s direction.</li>
        <li><strong>Avoid Obstacles:</strong> Stay clear of parked cars and other hazards. If you leave the road boundaries, you will incur penalties.</li>
        <li><strong>Collect Coins:</strong> Coins are scattered along the road. Collect them to earn bonus points.</li>
        <li><strong>Pause the Game:</strong> Press the <em>Spacebar</em> at any time to pause or resume the game.</li>
        <li><strong>Handle Curves & Bridges:</strong> Some road segments curve or feature bridges. Adjust your tilt to maintain control and stay on track.</li>
        <li><strong>Score Calculation:</strong> Your score increases with distance traveled and coins collected but decreases with penalties for off-track driving or collisions.</li>
        <li><strong>Game Duration:</strong> Select your desired game duration from the menu before starting.</li>
        <li><strong>Crash and Penalties:</strong> Collisions with obstacles result in a crash and loss of points. Drive carefully!</li>
      </ol>
      <button id="closeHowToPlay" type="button">Close</button>      
    </div>
  </div>

  <script>
    // ----------------------
    // Global Game Variables
    // ----------------------
    let scene, camera, renderer;
    let isPaused = false;
    let player;                // The player's car (Group object)
    let obstacles = [];        // Array of obstacle (parked) cars
    let coins = [];            // Array of collectible coins
    let roadSegments = [];     // Array of segments (road, water, bridge, etc.)
    let gameOver = false;
    let score = 0;
    let coinBonus = 0;         // Bonus score from coins
    let highScore = 0;         // Track the user's best score across attempts
    let gameDuration = 0;
    let gameStartTime = 0;
    let penalty = 0;
    let totalDistance = 0;
    let effectiveScore = 0;
    let bridgePenaltyActive = false;
    
    // Global variable for player name
    let playerName = "";

    // Movement / World logic
    const basePlayerSpeed = 0.3; // Base forward movement speed
    var playerSpeed = basePlayerSpeed;      
    var speedPercent = 0.0;
    const lateralSpeedFactor = 0.05; // Factor to convert tilt (in degrees) to lateral movement

    const forwardTiltLowerBound = 10.0; // Absolute values less than this cause the car to move at full speed
    const forwardTiltUpperBound = 20.0; // Absolute values higher than this will cause the car's movement to stop

    let currentTilt = { x: 0, y: 0, z: 0 }; // Latest IMU tilt values (in radians)
    let animationId; // To store the requestAnimationFrame ID

    // Infinite spawning logic
    let spawnZ = 0;            // How far we've spawned obstacles/segments
    const spawnDistance = 400; // Lookahead distance for spawning chunks earlier

    // Obstacle and road settings
    const obstacleSpacing = 20;
    const roadWidth = 20;      // Overall road width
    const minCarSeparation = 2.0; 
    const sideMargin = 1.0;

    // Audio
    const audio = document.getElementById("audio");

    // List of audio file options
    const audioFiles = [
        "audio/BackOnTrack.ogg",
        "audio/BaseAfterBase.ogg",
        "audio/BlastProcessing.ogg",
        "audio/CantLetGo.ogg",
        "audio/Clubstep.ogg",
        "audio/Clutterfunk.ogg",
        "audio/Cycles.ogg",
        "audio/Deadlocked.ogg",
        "audio/DryOut.ogg",
        "audio/Electrodynamix.ogg",
        "audio/Electroman.ogg",
        "audio/GeometricalDominator.ogg",
        "audio/HexagonForce.ogg",
        "audio/Jumper.ogg",
        "audio/menuLoop.ogg",
        "audio/Polargeist.ogg",
        "audio/secretLoop.ogg",
        "audio/StayInsideMe.ogg",
        "audio/StereoMadness.ogg",
        "audio/TheoryOfEverything.ogg",
        "audio/TheoryOfEverything2.ogg",
        "audio/TimeMachine.ogg",
        "audio/xStep.ogg"
    ];


    function playRandomAudio() {
        // Select a random file from the array
        const randomIndex = Math.floor(Math.random() * audioFiles.length);
        const selectedFile = audioFiles[randomIndex];

        // Set the selected file as the audio source
        audio.src = selectedFile;
        audio.volume = 0.4;
        audio.play();

        console.log(`Playing: ${selectedFile}`);
    }

    function stopAudio() {
        audio.pause();
        audio.currentTime = 0; // Reset playback
    }

    function changeSpeed(value) {
        audio.playbackRate = value;
        console.log(`Playback speed: ${value}`);
    }

    // Global flag to ensure no two consecutive bridge segments.
    let lastSegmentBridge = false;

    // ----------------------
    // Create a simple cartoon car for the player, oriented along +Z
    // ----------------------
    function createCartoonCar(color = 0x0000ff) {
      const carGroup = new THREE.Group();
      const bodyGeometry = new THREE.BoxGeometry(1, 0.5, 2);
      const bodyMaterial = new THREE.MeshPhongMaterial({ color });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.set(0, 0.25, 0);
      carGroup.add(body);
      const cabinGeometry = new THREE.BoxGeometry(1, 0.5, 1);
      const cabinMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
      const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
      cabin.position.set(0, 0.75, 0);
      carGroup.add(cabin);
      const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.2, 12);
      const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
      const frontLeftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
      frontLeftWheel.rotation.x = Math.PI / 2; 
      frontLeftWheel.position.set(0.4, 0, 0.7);
      carGroup.add(frontLeftWheel);
      const frontRightWheel = frontLeftWheel.clone();
      frontRightWheel.position.set(-0.4, 0, 0.7);
      carGroup.add(frontRightWheel);
      const backLeftWheel = frontLeftWheel.clone();
      backLeftWheel.position.set(0.4, 0, -0.7);
      carGroup.add(backLeftWheel);
      const backRightWheel = frontLeftWheel.clone();
      backRightWheel.position.set(-0.4, 0, -0.7);
      carGroup.add(backRightWheel);
      return carGroup;
    }

    // ----------------------
    // Create a parked car obstacle, also oriented along +Z
    // ----------------------
    function createParkedCar(color = 0xff0000) {
      const carGroup = new THREE.Group();
      const bodyGeometry = new THREE.BoxGeometry(1, 0.5, 2);
      const bodyMaterial = new THREE.MeshPhongMaterial({ color });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.set(0, 0.25, 0);
      carGroup.add(body);
      const cabinGeometry = new THREE.BoxGeometry(1, 0.5, 1);
      const cabinMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });
      const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
      cabin.position.set(0, 0.75, 0);
      carGroup.add(cabin);
      const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.2, 12);
      const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
      const frontLeftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
      frontLeftWheel.rotation.x = Math.PI / 2;
      frontLeftWheel.position.set(0.4, 0, 0.7);
      carGroup.add(frontLeftWheel);
      const frontRightWheel = frontLeftWheel.clone();
      frontRightWheel.position.set(-0.4, 0, 0.7);
      carGroup.add(frontRightWheel);
      const backLeftWheel = frontLeftWheel.clone();
      backLeftWheel.position.set(0.4, 0, -0.7);
      carGroup.add(backLeftWheel);
      const backRightWheel = frontLeftWheel.clone();
      backRightWheel.position.set(-0.4, 0, -0.7);
      carGroup.add(backRightWheel);
      return carGroup;
    }
    
    // ----------------------
    // Create a coin collectible
    // ----------------------
    function createCoin() {
      const coinGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 32);
      const coinMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00 });
      const coin = new THREE.Mesh(coinGeometry, coinMaterial);
      coin.rotation.x = Math.PI / 2;
      return coin;
    }

    // ----------------------
    // Utility Functions for Penalty and Animation
    // ----------------------
    function showScorePenalty(text) {
      const el = document.getElementById("scoreChange");
      el.textContent = text;
      el.style.display = "block";
      el.style.color = "red";
      let startTime = performance.now();
      let fadeInterval = setInterval(() => {
        let elapsed = performance.now() - startTime;
        if (elapsed > 1000) {
          clearInterval(fadeInterval);
          el.style.display = "none";
        } else {
          let opacity = 1 - (elapsed / 1000);
          el.style.opacity = opacity;
        }
      }, 50);
    }

    function showScoreIncrease(text) {
      const el = document.getElementById("scoreChange");
      el.textContent = text;
      el.style.display = "block";
      el.style.color = "yellow";
      let startTime = performance.now();
      let fadeInterval = setInterval(() => {
        let elapsed = performance.now() - startTime;
        if (elapsed > 1000) {
          clearInterval(fadeInterval);
          el.style.display = "none";
        } else {
          let opacity = 1 - (elapsed / 1000);
          el.style.opacity = opacity;
        }
      }, 50);
    }

    function animateCrash(object) {
      const originalPos = object.position.clone();
      const explosionPos = object.position.clone();
      const explosionSound = new Audio('audio/explosion.mp3');
      explosionSound.currentTime = 0; // Reset time to allow quick replay

      explosionSound.play();
      console.log(explosionPos);
      explosionPos.z -= 1;
      explosionPos.y += 1;

      // Load the explosion GIF texture
      const textureLoader = new THREE.TextureLoader();
      textureLoader.load('explosion.gif', function(texture) {
        // Create a sprite material using the explosion texture
        const spriteMaterial = new THREE.SpriteMaterial({
          map: texture,
          transparent: true
        });
        // Create the explosion sprite
        const explosionSprite = new THREE.Sprite(spriteMaterial);
        // Position it at the location of the crash
        explosionSprite.position.copy(explosionPos);
        // Adjust the scale to control the size of the explosion
        explosionSprite.scale.set(3, 3, 1);
        // Add the sprite to the scene
        scene.add(explosionSprite);

        // Remove the explosion effect after 1 second
        setTimeout(() => {
          scene.remove(explosionSprite);
          spriteMaterial.dispose();
          texture.dispose();
        }, 1000);
      });

  // Shake the object to simulate the crash impact
  const shakeDuration = 300;
  const startTime = performance.now();
  let shakeInterval = setInterval(() => {
    let elapsed = performance.now() - startTime;
    if (elapsed > shakeDuration) {
      clearInterval(shakeInterval);
      object.position.copy(originalPos);
    } else {
      object.position.x = originalPos.x + (Math.random() - 0.5) * 0.3;
      object.position.z = originalPos.z + (Math.random() - 0.5) * 0.3;
    }
  }, 30);
}
  function updateStopwatch() {
    // Calculate elapsed time in ms
    let elapsedMs = performance.now() - gameStartTime;
    // Calculate remaining time (ensure it's not negative)
    let remainingMs = gameDuration - elapsedMs;
    if (remainingMs < 0) remainingMs = 0;
    
    // Convert remaining time to seconds, then minutes & seconds
    let totalSec = Math.floor(remainingMs / 1000);
    let minutes = Math.floor(totalSec / 60);
    let seconds = totalSec % 60;
    let secondsStr = seconds < 10 ? "0" + seconds : seconds;
    
    document.getElementById("stopwatch").textContent = "Time: " + minutes + ":" + secondsStr;
  }


    // ----------------------
    // Segment definitions.
    // Each segment type defines a default length and a spawn() method that creates its objects.
    // ----------------------
    const segmentTypes = {
      straightRoad: {
        length: 50,
        spawn: function(zStart, length) {
          const geometry = new THREE.PlaneGeometry(roadWidth, length);
          const material = new THREE.MeshPhongMaterial({ color: 0x444444 });
          const road = new THREE.Mesh(geometry, material);
          road.rotation.x = -Math.PI / 2;
          road.position.z = zStart + length / 2;
          road.userData = {
            segmentType: "straightRoad",
            zStart: zStart,
            zEnd: zStart + length,
          }
          scene.add(road);
          roadSegments.push(road);

          const dashLength = 2, dashSpace = 4;
          const dashCount = Math.floor(length / dashSpace);
          for (let i = 0; i < dashCount; i++) {
            const dashZ = zStart + i * dashSpace + dashSpace / 2;
            const dashGeom = new THREE.PlaneGeometry(0.2, dashLength);
            const dashMat = new THREE.MeshPhongMaterial({ color: 0xffff00 });
            const dash = new THREE.Mesh(dashGeom, dashMat);
            dash.rotation.x = -Math.PI / 2;
            dash.position.set(0, 0.01, dashZ);
            scene.add(dash);
            roadSegments.push(dash);
          }

          const leftLineGeom = new THREE.PlaneGeometry(0.1, length);
          const leftLineMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
          const leftLine = new THREE.Mesh(leftLineGeom, leftLineMat);
          leftLine.rotation.x = -Math.PI / 2;
          leftLine.position.set(-roadWidth / 2, 0.01, zStart + length / 2);
          scene.add(leftLine);
          roadSegments.push(leftLine);
          const rightLine = leftLine.clone();
          rightLine.position.set(roadWidth / 2, 0.01, zStart + length / 2);
          scene.add(rightLine);
          roadSegments.push(rightLine);

          for (let z = zStart + obstacleSpacing; z < zStart + length; z += obstacleSpacing) {
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffffff, 0xffa500];
            const obstacleCount = 2 + Math.floor(Math.random() * 2);
            const chosenXPositions = [];
            for (let i = 0; i < obstacleCount; i++) {
              let attemptCount = 0, foundSpot = false, xPos = 0;
              while (attemptCount < 10 && !foundSpot) {
                const minX = -roadWidth / 2 + sideMargin;
                const maxX = roadWidth / 2 - sideMargin;
                xPos = Math.random() * (maxX - minX) + minX;
                let tooClose = false;
                for (let px of chosenXPositions) {
                  if (Math.abs(xPos - px) < minCarSeparation) {
                    tooClose = true;
                    break;
                  }
                }
                if (!tooClose) {
                  foundSpot = true;
                  chosenXPositions.push(xPos);
                }
                attemptCount++;
              }
              if (foundSpot) {
                const randColor = colors[Math.floor(Math.random() * colors.length)];
                const parkedCar = createParkedCar(randColor);
                parkedCar.position.set(xPos, 0, z);
                scene.add(parkedCar);
                obstacles.push(parkedCar);
              }
            }
          }
        },
        handleCollisions: function(data) {
          // Only process if player's Z is within this segment
          if (player.position.z >= data.zStart && player.position.z <= data.zEnd) {
            // Ensure we have a global timer
            if (!window.lastStraightPenaltyTime) {
              window.lastStraightPenaltyTime = 0;
            }

            // If the car is beyond the left boundary, clamp + penalty -1 (but only if 500ms have passed)
            if (player.position.x < -roadWidth / 2) {
              player.position.x = -roadWidth / 2;
              let now = performance.now();
              if (now - window.lastStraightPenaltyTime >= 300) {
                penalty += 1;  // single event penalty
                showScorePenalty("-1");
                updateScore();
                window.lastStraightPenaltyTime = now;
              }
            }

            // If the car is beyond the right boundary, clamp + penalty -1
            if (player.position.x > roadWidth / 2) {
              player.position.x = roadWidth / 2;
              let now = performance.now();
              if (now - window.lastStraightPenaltyTime >= 300) {
                penalty += 1;
                showScorePenalty("-1");
                updateScore();
                window.lastStraightPenaltyTime = now;
              }
            }
          }
        }
      },
      curvedRoad: {
        length: 100,
        spawn: function(zStart, length) {
          const wavePeriod = 1;
          const waveWidth = 1;
          const numPoints = 50;
          const leftCurvePoints = [];
          const rightCurvePoints = [];
          const middleCurvePoints = [];

          for (let i = 0; i < numPoints; i++) {
            const t = i / (numPoints - 1);
            const z = zStart + t * length;
            const offsetX = (waveWidth * roadWidth * 0.5) * Math.sin(t * wavePeriod * 2 * Math.PI) - (waveWidth * roadWidth * 0.5);
            const y = 0.02;
            leftCurvePoints.push(new THREE.Vector3(offsetX, y, z));
            rightCurvePoints.push(new THREE.Vector3(offsetX + roadWidth, y, z));
            middleCurvePoints.push(new THREE.Vector3(offsetX + roadWidth * 0.5, y, z));
          }

          const roadGeometry = new THREE.BufferGeometry();
          const positions = [];
          for (let i = 0; i < numPoints - 1; i++) {
            const pA = leftCurvePoints[i];
            const pB = rightCurvePoints[i];
            const pC = leftCurvePoints[i+1];
            const pD = rightCurvePoints[i+1];
            positions.push(pA.x, pA.y, pA.z);
            positions.push(pB.x, pB.y, pB.z);
            positions.push(pC.x, pC.y, pC.z);
            positions.push(pB.x, pB.y, pB.z);
            positions.push(pD.x, pD.y, pD.z);
            positions.push(pC.x, pC.y, pC.z);
          }
          const positionAttribute = new THREE.Float32BufferAttribute(positions, 3);
          roadGeometry.setAttribute('position', positionAttribute);
          const roadMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x808080,
            side: THREE.DoubleSide 
          });
          const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
          const leftGeometry = new THREE.BufferGeometry().setFromPoints(leftCurvePoints);
          const rightGeometry = new THREE.BufferGeometry().setFromPoints(rightCurvePoints);
          const middleGeometry = new THREE.BufferGeometry().setFromPoints(middleCurvePoints);
          const dashedMaterial = new THREE.LineDashedMaterial({
            color: 0xffff00,
            dashSize: 2,
            gapSize: 1
          });
          const leftLine = new THREE.Line(leftGeometry, dashedMaterial);
          const rightLine = new THREE.Line(rightGeometry, dashedMaterial);
          const centerDashedMaterial = new THREE.LineDashedMaterial({
            color: 0xffffff,
            dashSize: 2,
            gapSize: 1
          });
          const middleLine = new THREE.Line(middleGeometry, centerDashedMaterial);
          leftLine.computeLineDistances();
          rightLine.computeLineDistances();
          middleLine.computeLineDistances();
          [leftLine, rightLine, middleLine].forEach(line => {
            line.userData = {
              segmentType: 'curvedRoad',
              zStart: zStart,
              zEnd: zStart + length,
              wavePeriod: wavePeriod,
              waveWidth: waveWidth,
              segmentLength: length
            };
          });
          scene.add(roadMesh);
          scene.add(leftLine);
          scene.add(rightLine);
          scene.add(middleLine);
          roadSegments.push(leftLine);
          roadSegments.push(rightLine);
          roadSegments.push(middleLine);
          for (let i = 0; i < numPoints; i++) {
            let r = Math.random();
            // Blue coin: appears at the middle of the curved path (value +5)
            if (r < 0.2) {
              const coin_gold = createCoin();
              coin_gold.material.color.set("#FFD700"); // gold
              coin_gold.userData.value = 3;
              coin_gold.position.copy(middleCurvePoints[i]);
              coin_gold.position.y += 0.5;
              scene.add(coin_gold);
              coins.push(coin_gold);

            // Gold coin: appears further to the left/right (value +2)
              const coin_silver = createCoin();
              coin_silver.material.color.set("#C0C0C0"); // silver
              coin_silver.userData.value = 2;
              // Offset by Â±2.5 from the middle
              offset1 = (Math.random() < 0.5 ? -4 : 4);
              coin_silver.position.copy(middleCurvePoints[i]);
              coin_silver.position.x += offset1;
              coin_silver.position.y += 0.5;
              scene.add(coin_silver);
              coins.push(coin_silver);

            // Copper coin: appears near the edges (value +1)
              const coin_copper = createCoin();
              coin_copper.material.color.set("#B87333"); // copper color
              coin_copper.userData.value = 1;
              // Offset by Â±4 from the middle (placing it near the edge but not exactly at border)
              offset2 = (Math.random() < 0.5 ? -8 : 8);
              coin_copper.position.copy(middleCurvePoints[i]);
              coin_copper.position.x += offset2;
              coin_copper.position.y += 0.5;
              scene.add(coin_copper);
              coins.push(coin_copper);
            }
          }
        },
        handleCollisions: function(data) {
          // Only process if player's Z is within this segment
          if (player.position.z >= data.zStart && player.position.z <= data.zEnd) {
            if (!window.lastCurvedPenaltyTime) {
              window.lastCurvedPenaltyTime = 0;
            }

            // figure out the dynamic left/right boundaries
            const segLength = data.segmentLength;
            const t = (player.position.z - data.zStart) / segLength;
            const centerX = (data.waveWidth * roadWidth * 0.5) * Math.sin(t * data.wavePeriod * 2 * Math.PI);
            const minX = centerX - (roadWidth / 2);
            const maxX = centerX + (roadWidth / 2);

            // If car is beyond left boundary, clamp + penalty -2 every 500ms
            if (player.position.x < minX) {
              player.position.x = minX;
              let now = performance.now();
              if (now - window.lastCurvedPenaltyTime >= 300) {
                penalty += 2;
                showScorePenalty("-2");
                updateScore();
                window.lastCurvedPenaltyTime = now;
              }
            }

            // If car is beyond right boundary, clamp + penalty -2
            if (player.position.x > maxX) {
              player.position.x = maxX;
              let now = performance.now();
              if (now - window.lastCurvedPenaltyTime >= 300) {
                penalty += 2;
                showScorePenalty("-2");
                updateScore();
                window.lastCurvedPenaltyTime = now;
              }
            }
          }
        }

      },
      bridge: {
        length: 80,
        spawn: function(zStart, length) {
          // Main 20-wide road plane (light gray)
          const geometry = new THREE.PlaneGeometry(20, length);
          const material = new THREE.MeshPhongMaterial({ color: 0xaaaaaa });
          const cautionRoad = new THREE.Mesh(geometry, material);
          cautionRoad.rotation.x = -Math.PI / 2;
          cautionRoad.position.z = zStart + length / 2;
          scene.add(cautionRoad);
          roadSegments.push(cautionRoad);

          // We'll place horizontal stripes from X=Â±2 outward in four zones:
          // zone1: X from Â±2..Â±4, zone2: Â±4..Â±6, zone3: Â±6..Â±8, zone4: Â±8..Â±10
          // Each zone has black/yellow stripes. The further the zone, the denser the stripes.
          // We'll define a helper to spawn horizontal stripes in a given zone range.
          function spawnHorizontalStripes(xMin, xMax, stripeCount, color1, color2) {
            // We create 'stripeCount' horizontal stripes, alternating color1/color2
            let zoneWidth = Math.abs(xMax - xMin);
            let stripeHeight = length / stripeCount;
            for (let i = 0; i < stripeCount; i++) {
              const stripeGeom = new THREE.PlaneGeometry(zoneWidth, stripeHeight);
              // alternate color by i % 2
              const stripeMat = new THREE.MeshPhongMaterial({ color: (i % 2 === 0 ? color1 : color2) });
              const stripe = new THREE.Mesh(stripeGeom, stripeMat);
              stripe.rotation.x = -Math.PI / 2;

              // position it horizontally in the middle of [xMin, xMax]
              stripe.position.x = (xMin + xMax) / 2;
              // position it vertically along Z
              stripe.position.z = zStart + ((i + 0.5) * stripeHeight);
              stripe.position.y = 0.01;
              scene.add(stripe);
              roadSegments.push(stripe);
            }
          }

          // zone1 => Â±2..Â±4, e.g. 12 stripes
          spawnHorizontalStripes(2, 4, 12, 0x000000, 0xffff00);
          spawnHorizontalStripes(-4, -2, 12, 0x000000, 0xffff00);

          // zone2 => Â±4..Â±6 => 14 stripes
          spawnHorizontalStripes(4, 6, 14, 0x000000, 0xffff00);
          spawnHorizontalStripes(-6, -4, 14, 0x000000, 0xffff00);

          // zone3 => Â±6..Â±8 => 16 stripes
          spawnHorizontalStripes(6, 8, 16, 0x000000, 0xffff00);
          spawnHorizontalStripes(-8, -6, 16, 0x000000, 0xffff00);

          // zone4 => Â±8..Â±10 => 18 stripes
          spawnHorizontalStripes(8, 10, 18, 0x000000, 0xffff00);
          spawnHorizontalStripes(-10, -8, 18, 0x000000, 0xffff00);

          // Store safe zone boundaries, etc.
          cautionRoad.userData = {
            segmentType: "bridge",
            isBridge: true,
            zone1: 4,
            zone2: 6,
            zone3: 8,
            zone4: 10,
            segmentLength: length,
            zStart: zStart,
            zEnd: zStart + length
          };
        },

        handleCollisions: function(data) {
          // Only process if player's Z is within this segment
          if (player.position.z >= data.zStart && player.position.z <= data.zEnd) {

            // If first time in segment, reinit penalty timer
            if (!window.lastPenaltySegment || window.lastPenaltySegment !== data) {
              window.lastPenaltySegment = data;
              window.lastPenaltyUpdate = performance.now();
              window.offTrackTime = 0;
              // ADD a timer for on-track reward
              window.onTrackTime = 0;
            }

            // clamp X to Â±10 so we never leave the road
            if (player.position.x < -10) player.position.x = -10;
            if (player.position.x >  10) player.position.x =  10;

            // figure out how far from center Â±2 => zone1 => zone2 => zone3 => zone4
            let now = performance.now();
            let deltaTime = now - window.lastPenaltyUpdate; // ms
            window.lastPenaltyUpdate = now;
            let distFromSafe = 0; 
            // safe zone is Â±2, if outside Â±2 => distFromSafe = how far from Â±2
            if (player.position.x > 2) {
              distFromSafe = player.position.x - 2;
            } else if (player.position.x < -2) {
              distFromSafe = Math.abs(player.position.x) - 2;
            }

            // if distFromSafe <= 0 => no penalty => accumulate onTrackTime
            if (distFromSafe <= 0) {
              // car is in safe zone => reward +1 for each 500 ms
              window.onTrackTime += deltaTime;
              while (window.onTrackTime >= 350) {
                // add points
                coinBonus += 1;
                showScoreIncrease("+1");
                updateScore();
                window.onTrackTime -= 350;
              }
              // reset offTrackTime
              window.offTrackTime = 0;
            } else {
              // if distFromSafe > 0 => existing logic for penalty
              window.offTrackTime = (window.offTrackTime || 0) + deltaTime;

              // figure out penalty rate based on zone
              let rate = 0;
              if (distFromSafe < 2) rate = 1;       // zone1 => Â±4
              else if (distFromSafe < 4) rate = 2;  // zone2 => Â±6
              else if (distFromSafe < 6) rate = 3;  // zone3 => Â±8
              else rate = 4;                        // zone4 => Â±10

              // for each full ms off track => penalty += rate
              while (window.offTrackTime >= 250) {
                penalty += rate;
                showScorePenalty("-" + rate);
                updateScore();
                window.offTrackTime -= 250;
              }
              // reset onTrackTime
              window.onTrackTime = 0;
            }

          } else {
            // if not in this segment => reset so next time we reenter, we init
            if (window.lastPenaltySegment === data) {
              window.lastPenaltySegment = null;
              window.lastPenaltyUpdate = null;
              window.offTrackTime = 0;
              window.onTrackTime = 0;
            }
          }
        }
      }


    };

    // ----------------------
    // Unified function to spawn a segment chunk.
    // ----------------------
    function spawnChunk(zStart) {
      let segmentType;
      if (zStart === 0 || lastSegmentBridge) {
        segmentType = "straightRoad";
      } else {
        const rand = Math.random();
        if (rand < 0.15) {
          segmentType = "bridge";
        } else if (rand < 0.35) {
          segmentType = "curvedRoad";
        } else {
          segmentType = "straightRoad";
        }
      }
      let baseLength = segmentTypes[segmentType].length;
      let segmentLength = baseLength * (0.8 + Math.random() * 0.4);
      segmentTypes[segmentType].spawn(zStart, segmentLength);
      lastSegmentBridge = (segmentType === "bridge");
      spawnZ += segmentLength;
    }

    // ----------------------
    // Initialize the three.js scene and game objects
    // ----------------------
    function init() {
      if (renderer && renderer.domElement) {
        document.body.removeChild(renderer.domElement);
      }
      var carColor = window.selectedCarColor;
      player = createCartoonCar(carColor);
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, -10);
      camera.lookAt(0, 0, 0);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.domElement.style.position = "absolute";
      renderer.domElement.style.zIndex = "0";
      document.body.appendChild(renderer.domElement);
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(0, 50, -50);
      player = createCartoonCar(carColor);
      scene.add(directionalLight);
      player.position.set(0, 0, 0);
      scene.add(player);
      spawnZ = 0;
      obstacles = [];
      roadSegments = [];
      coins = [];
      coinBonus = 0;
      penalty = 0;
      score = 0;
      effectiveScore = 0;
      gameOver = false;
      document.getElementById("gameOver").style.display = "none";
      document.getElementById("restartGameBtn").style.display = "none";
      lastSegmentBridge = false;
      spawnChunk(spawnZ);
      window.addEventListener('resize', onWindowResize, false);
      const timeSelect = document.getElementById("gameTimeSelect");
      const chosenMs = parseInt(timeSelect.value, 10);
      gameDuration = chosenMs;
      gameStartTime = performance.now();
      animate();
    }

    // ----------------------
    // Adjust camera and renderer on window resize
    // ----------------------
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ----------------------
    // Check for collisions with obstacles and apply penalty
    // ----------------------
    function checkCollisions() {
      const playerBox = new THREE.Box3().setFromObject(player);
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const obs = obstacles[i];
        const obsBox = new THREE.Box3().setFromObject(obs);
        if (playerBox.intersectsBox(obsBox)) {
          penalty += 2;
          showScorePenalty("-2");
          animateCrash(player);
          updateScore();
          scene.remove(obs);
          obstacles.splice(i, 1);
        }
      }
    }

    // ----------------------
    // Update score based on player's position, coins, and penalty
    // ----------------------
    function updateScore() {
      score = Math.floor(totalDistance/20) + coinBonus;
      effectiveScore = score - penalty;
      document.getElementById("score").textContent = "Score: " + effectiveScore;
    }

    // ----------------------
    // Update high score if needed
    // ----------------------
    function updateHighScore() {
      if (effectiveScore > highScore) {
        highScore = effectiveScore;
      }
      document.getElementById("highScore").textContent = "High Score: " + highScore;
    }

    // ----------------------
    // The main animation loop
    // ----------------------
    function animate() {
      if (gameOver) return;
      animationId = requestAnimationFrame(animate);

      const absoluteForwardTiltInDegrees = Math.abs(currentTilt.y * (180 / Math.PI));
      if (absoluteForwardTiltInDegrees <= forwardTiltLowerBound) {
        speedPercent = 1.0;
      } else if (absoluteForwardTiltInDegrees > forwardTiltUpperBound) {
        speedPercent = 0.0;
      } else {
        const currDifference = Math.abs(absoluteForwardTiltInDegrees - forwardTiltUpperBound);
        speedPercent = currDifference / (forwardTiltUpperBound - forwardTiltLowerBound);
      }

      changeSpeed(speedPercent);
      playerSpeed = basePlayerSpeed * speedPercent;
      player.position.z += playerSpeed;
      const tiltInDegrees = -currentTilt.x * (180 / Math.PI);
      player.position.x += tiltInDegrees * lateralSpeedFactor * speedPercent;
      player.position.z += playerSpeed;
      totalDistance += playerSpeed;
      camera.position.z = player.position.z - 10;
      camera.position.x = player.position.x;
      camera.lookAt(player.position.x, player.position.y, player.position.z);

      for (let seg of roadSegments) {
        const data = seg.userData;
        if (!data) continue;
        if (player.position.z >= data.zStart && player.position.z <= data.zEnd) {
          if (segmentTypes[data.segmentType] && segmentTypes[data.segmentType].handleCollisions) {
            segmentTypes[data.segmentType].handleCollisions(data);
          }
        }
      }

      // Rotate coins and check for collection
      const playerBox = new THREE.Box3().setFromObject(player);
      for (let i = coins.length - 1; i >= 0; i--) {
        coins[i].rotation.z += 0.05;
        const coinSphere = new THREE.Sphere(coins[i].position, 0.5);
        if (playerBox.intersectsSphere(coinSphere)) {
          // Use the coin's stored value (default to 1 if not set)
          const coinValue = coins[i].userData.value || 1;
          showScoreIncrease((coinValue > 0 ? "+" : "") + coinValue);
          const coinSound = new Audio('coin.mp3');
          coinSound.currentTime = 0;
          coinSound.play();
          scene.remove(coins[i]);
          coins.splice(i, 1);
          coinBonus += coinValue;
        }
}

      if (player.position.z + spawnDistance > spawnZ) {
        spawnChunk(spawnZ);
      }

      checkCollisions();
      updateScore();

      const elapsed = performance.now() - gameStartTime;
      if (elapsed >= gameDuration) {
        endGame();
        return;
      }
      updateStopwatch();
      renderer.render(scene, camera);
    }

    // ----------------------
    // End the game
    // ----------------------
    function endGame() {
      stopAudio();
      gameOver = true;
      cancelAnimationFrame(animationId);
      updateHighScore();
      const overlay = document.getElementById("gameOver");
      overlay.textContent = "Game Over";
      overlay.style.color = "#ff0000";
      overlay.style.fontWeight = "bold";
      overlay.style.fontSize = "60px";
      overlay.style.display = "block";
      document.getElementById("gameOver").style.display = "block";
      document.getElementById("restartGameBtn").style.display = "block";
      document.getElementById("homeBtn").style.display = "block";
    }

    // ----------------------
    // Restart the game with a countdown
    // ----------------------
    function restartGame() {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      obstacles.forEach(o => scene.remove(o));
      roadSegments.forEach(r => scene.remove(r));
      coins.forEach(c => scene.remove(c));
      scene.remove(player);
      obstacles = [];
      roadSegments = [];
      coins = [];
      coinBonus = 0;
      penalty = 0;
      score = 0;
      effectiveScore = 0;
      totalDistance = 0;
      document.getElementById("gameOver").style.display = "none";
      document.getElementById("restartGameBtn").style.display = "none";
      startCountdown(init);
    }

    // ----------------------
    // Countdown function before starting the game
    // ----------------------
    function startCountdown(callback) {
      const countdownEl = document.getElementById("countdown");
      let count = 3;
      countdownEl.style.display = "block";
      countdownEl.textContent = count;
      const interval = setInterval(() => {
        count--;
        if (count > 0) {
          countdownEl.textContent = count;
        } else {
          clearInterval(interval);
          countdownEl.textContent = "Go!";
          setTimeout(() => {
            countdownEl.style.display = "none";
            callback();
          }, 500);
        }
      }, 1000);
      playRandomAudio();
    }

    // ----------------------
    // WebSocket (IMU Data) Code
    // ----------------------
    let socket = null;
    let patternTimeout = null;

    document.getElementById("connectBtn").addEventListener("click", function() {
      const imuId = document.getElementById("imuIdInput").value.trim();
      if (!imuId) {
        alert("Please enter an IMU ID.");
        return;
      }
      const wsUrl = `wss://personal-site-oi5a.onrender.com/imu_racing_game/api/ws/imu/${imuId}/broadcast/`;
      console.log("Connecting to", wsUrl);
      if (socket) {
        socket.close();
      }
      socket = new WebSocket(wsUrl);
      socket.onopen = function(event) {
        console.log("Connected to:", wsUrl);
        //document.getElementById("wsMessage").textContent = "Connected to: " + wsUrl;
      };
      socket.onmessage = function(event) {

        // UNCOMMENT THIS FOR DEBUG
        //document.getElementById("wsMessage").textContent = event.data;
        try {
          const msg = JSON.parse(event.data);
          if (msg.data && msg.data.tilt) {
            currentTilt = msg.data.tilt;
            detectGesture(currentTilt);
          }
        } catch (e) {
          console.error("Error parsing message:", e);
        }
      };
      socket.onclose = function(event) {
        console.log("Disconnected from server");
        //document.getElementById("wsMessage").textContent = "Disconnected from server";
      };
      socket.onerror = function(error) {
        console.error("WebSocket error:", error);
        //document.getElementById("wsMessage").textContent = "WebSocket error. Check the console for details.";
      };
    });

    const REQUIRED_DURATION = 3000;
    let yThresholdStartTime = null;

    function detectGesture(tilt) {
      if(document.getElementById("gameOver").style.display == "none"){
        return;
      }
      if (tilt.y > 0.5) {
        if (yThresholdStartTime === null) {
          yThresholdStartTime = Date.now();
          console.log("Y threshold exceeded, starting timer...");
        } else {
          const elapsedTime = Date.now() - yThresholdStartTime;
          console.log(`Y threshold maintained for ${(elapsedTime/1000).toFixed(1)} seconds`);
          if (elapsedTime >= REQUIRED_DURATION) {
            document.getElementById("startGameBtn").click();
            delay(5000);
          }
        }
      } else {
        if (yThresholdStartTime !== null) {
          console.log("Y value dropped below threshold, resetting timer");
          yThresholdStartTime = null;
        }
      }
    }

    document.getElementById("restartGameBtn").addEventListener("click", function() {
      restartGame();
    });
    
    document.getElementById("homeBtn").addEventListener("click", function() {
      window.location.reload();
    });


    (function() {
      const urlParams = new URLSearchParams(window.location.search);
      const autoImuId = urlParams.get('id');
      if (autoImuId) {
        document.getElementById("imuIdInput").value = autoImuId;
        document.getElementById("connectBtn").click();
      }
    })();

    // NEW: How To Play overlay toggle
    document.getElementById("howToPlayBtn").addEventListener("click", function() {
      document.getElementById("howToPlayOverlay").style.display = "block";
    });

    document.getElementById("closeHowToPlay").addEventListener("click", function() {
      document.getElementById("howToPlayOverlay").style.display = "none";
    });

    document.getElementById("startGameMenuBtn").addEventListener("click", function() {
      const chosenColor = document.getElementById("vehicleColor").value;
      // Store the selected color in a global variable for use in init():
      window.selectedCarColor = parseInt(chosenColor.replace("#", "0x"));
      document.getElementById("menuScreen").style.display = "none";
      // Show game HUD elements (score, highScore, stopwatch)
      document.getElementById("score").style.display = "block";
      document.getElementById("highScore").style.display = "block";
      document.getElementById("stopwatch").style.display = "block";
      // Instead of clicking a hidden button, start the game directly:
      startCountdown(init);
    });

    // NEW: Update title color when vehicle color is changed
    document.getElementById("vehicleColor").addEventListener("input", function() {
    document.getElementById("gameTitle").style.color = this.value;
    // Optionally, update text shadow for a stronger glow effect matching the chosen color:
    //document.getElementById("gameTitle").style.textShadow = `0 0 5px ${this.value}, 0 0 10px ${this.value}`;
  });

  document.addEventListener("keydown", function(e) {
    if (gameOver) return;  // Do not allow pausing/resuming after game over
    if (e.code === "Space") {
      if (!isPaused) {
        isPaused = true;
        cancelAnimationFrame(animationId);
        // Display "Paused" with bold white styling and different size
        const overlay = document.getElementById("gameOver");
        overlay.textContent = "Paused";
        overlay.style.display = "block";
        overlay.style.color = "#ffffff";
        overlay.style.fontWeight = "bold";
        overlay.style.fontSize = "40px";
        // Pause the music
        audio.pause();
        // Show Home button if desired (assumes homeBtn exists)
        document.getElementById("homeBtn").style.display = "block";
      } else {
        isPaused = false;
        const overlay = document.getElementById("gameOver");
        overlay.style.display = "none";
        document.getElementById("homeBtn").style.display = "none";
        // Resume music playback
        audio.play();
        animate();
      }
    }
  });
  </script>
</body>
</html>
