<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>IMU Game - Endless Runner (Car Version)</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #score {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 24px;
      z-index: 1;
    }
    #highScore {
      position: absolute;
      top: 40px;
      left: 10px;
      color: gold;
      font-size: 20px;
      z-index: 1;
    }
    #wsMessage {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 16px;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      z-index: 1;
      max-width: 80%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: red;
      font-size: 48px;
      display: none;
      z-index: 1;
    }
    /* Updated countdown style for better visibility */
    #countdown {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 72px;
      display: none;
      z-index: 1000;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 20px 40px;
      border-radius: 10px;
    }
    #imuPanel {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.5);
      color: white;
      padding: 10px;
      z-index: 1;
    }
    #startGameBtn {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 18px;
      z-index: 1;
    }
    #restartGameBtn {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 18px;
      z-index: 1;
      display: none; /* Shown only when game is over */
    }
  </style>
  <!-- Include three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
  <!-- Score display -->
  <div id="score">Score: 0</div>
  <div id="scoreChange" style="
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: red;
  font-size: 50px;
  z-index: 10;
  display: none;
  "></div>
  <div id="penaltyText" style="
  position: absolute;
  font-size: 20px;
  color: red;
  display: none;   /* hidden by default */
  z-index: 9999;   /* on top of other UI */
  pointer-events: none; /* ignore mouse events */
  "></div>
  <div id="stopwatch" style="
  position: absolute;
  top: 70px; left: 10px;  /* below the highScore which is top=40px */
  color: white;
  font-size: 24px;
  z-index: 10;
  ">
  Time: 0:00
  </div>
  <!-- High score display -->
  <div id="highScore">High Score: 0</div>
  <!-- Most recent WebSocket message display -->
  <div id="wsMessage">Latest Message: </div>
  <!-- Game Over message -->
  <div id="gameOver">Game Over</div>
  <!-- Countdown display -->
  <div id="countdown"></div>
  <!-- IMU connection panel -->
  <div id="imuPanel">
    <label for="imuIdInput">Enter IMU ID:</label>
    <input type="text" id="imuIdInput" placeholder="e.g., my_imu_id" />
    <button id="connectBtn">Connect</button>
  </div>
  <!-- Start Game button -->
  <button id="startGameBtn">Start Game</button>
  <!-- Restart Game button -->
  <button id="restartGameBtn">Restart</button>
  
  <script>
    // ----------------------
    // Three.js Game Variables
    // ----------------------
    let scene, camera, renderer;
    let player;                // The player's car (Group object)
    let obstacles = [];        // Array of obstacle (parked) cars
    let roadSegments = [];     // Array of segments (road, water, bridge, etc.)
    let gameOver = false;
    let score = 0;
    let highScore = 0;         // Track the user's best score across attempts
    var effectiveScore = 0;
    let gameDuration = 5000; // 1 minute = 60,000 ms
    let gameStartTime = 0;
    let baseDistance = 0;
    let penalty = 0;
    let bridgePenaltyActive = false;
    // Movement / World logic
    const playerSpeed = 0.2;         // Constant forward movement speed
    const lateralSpeedFactor = 0.01; // Factor to convert tilt (in degrees) to lateral movement
    let currentTilt = { x: 0, y: 0, z: 0 }; // Latest IMU tilt values (in radians)
    let animationId; // To store the requestAnimationFrame ID

    // Infinite spawning logic
    let spawnZ = 0;            // How far we've spawned obstacles/segments
    const spawnDistance = 400; // Lookahead distance for spawning chunks earlier

    // Obstacle and road settings
    const obstacleSpacing = 20;
    const roadWidth = 20;      // Overall road width
    const minCarSeparation = 2.0; 
    const sideMargin = 1.0;

    // Global flag to ensure no two consecutive bridge segments.
    let lastSegmentBridge = false;

    // ----------------------
    // Create a simple cartoon car for the player, oriented along +Z
    // ----------------------
    function createCartoonCar(color = 0x0000ff) {
      const carGroup = new THREE.Group();
      const bodyGeometry = new THREE.BoxGeometry(1, 0.5, 2);
      const bodyMaterial = new THREE.MeshPhongMaterial({ color });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.set(0, 0.25, 0);
      carGroup.add(body);
      const cabinGeometry = new THREE.BoxGeometry(1, 0.5, 1);
      const cabinMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
      const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
      cabin.position.set(0, 0.75, 0);
      carGroup.add(cabin);
      const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.2, 12);
      const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
      const frontLeftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
      frontLeftWheel.rotation.x = Math.PI / 2; 
      frontLeftWheel.position.set(0.4, 0, 0.7);
      carGroup.add(frontLeftWheel);
      const frontRightWheel = frontLeftWheel.clone();
      frontRightWheel.position.set(-0.4, 0, 0.7);
      carGroup.add(frontRightWheel);
      const backLeftWheel = frontLeftWheel.clone();
      backLeftWheel.position.set(0.4, 0, -0.7);
      carGroup.add(backLeftWheel);
      const backRightWheel = frontLeftWheel.clone();
      backRightWheel.position.set(-0.4, 0, -0.7);
      carGroup.add(backRightWheel);
      return carGroup;
    }

    // ----------------------
    // Create a parked car obstacle, also oriented along +Z
    // ----------------------
    function createParkedCar(color = 0xff0000) {
      const carGroup = new THREE.Group();
      const bodyGeometry = new THREE.BoxGeometry(1, 0.5, 2);
      const bodyMaterial = new THREE.MeshPhongMaterial({ color });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.set(0, 0.25, 0);
      carGroup.add(body);
      const cabinGeometry = new THREE.BoxGeometry(1, 0.5, 1);
      const cabinMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });
      const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
      cabin.position.set(0, 0.75, 0);
      carGroup.add(cabin);
      const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.2, 12);
      const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
      const frontLeftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
      frontLeftWheel.rotation.x = Math.PI / 2;
      frontLeftWheel.position.set(0.4, 0, 0.7);
      carGroup.add(frontLeftWheel);
      const frontRightWheel = frontLeftWheel.clone();
      frontRightWheel.position.set(-0.4, 0, 0.7);
      carGroup.add(frontRightWheel);
      const backLeftWheel = frontLeftWheel.clone();
      backLeftWheel.position.set(0.4, 0, -0.7);
      carGroup.add(backLeftWheel);
      const backRightWheel = frontLeftWheel.clone();
      backRightWheel.position.set(-0.4, 0, -0.7);
      carGroup.add(backRightWheel);
      return carGroup;
    }

    // ----------------------
    // Segment definitions.
    // Each segment type defines a default length and a spawn() method that creates its objects.
    // ----------------------
    const segmentTypes = {
      road: {
        length: 50, // Default road segment length.
        spawn: function(zStart, length) {
          // Spawn the road surface.
          const geometry = new THREE.PlaneGeometry(roadWidth, length);
          const material = new THREE.MeshPhongMaterial({ color: 0x444444 });
          const road = new THREE.Mesh(geometry, material);
          road.rotation.x = -Math.PI / 2;
          road.position.z = zStart + length / 2;
          scene.add(road);
          roadSegments.push(road);

          // Spawn road lines (dashes).
          const dashLength = 2, dashSpace = 4;
          const dashCount = Math.floor(length / dashSpace);
          for (let i = 0; i < dashCount; i++) {
            const dashZ = zStart + i * dashSpace + dashSpace / 2;
            const dashGeom = new THREE.PlaneGeometry(0.2, dashLength);
            const dashMat = new THREE.MeshPhongMaterial({ color: 0xffff00 });
            const dash = new THREE.Mesh(dashGeom, dashMat);
            dash.rotation.x = -Math.PI / 2;
            dash.position.set(0, 0.01, dashZ);
            scene.add(dash);
            roadSegments.push(dash);
          }

          // Spawn left and right boundary lines.
          const leftLineGeom = new THREE.PlaneGeometry(0.1, length);
          const leftLineMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
          const leftLine = new THREE.Mesh(leftLineGeom, leftLineMat);
          leftLine.rotation.x = -Math.PI / 2;
          leftLine.position.set(-roadWidth / 2, 0.01, zStart + length / 2);
          scene.add(leftLine);
          roadSegments.push(leftLine);
          const rightLine = leftLine.clone();
          rightLine.position.set(roadWidth / 2, 0.01, zStart + length / 2);
          scene.add(rightLine);
          roadSegments.push(rightLine);

          // Spawn obstacles within this road segment.
          for (let z = zStart + obstacleSpacing; z < zStart + length; z += obstacleSpacing) {
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffffff, 0xffa500];
            const obstacleCount = 2 + Math.floor(Math.random() * 2);
            const chosenXPositions = [];
            for (let i = 0; i < obstacleCount; i++) {
              let attemptCount = 0, foundSpot = false, xPos = 0;
              while (attemptCount < 10 && !foundSpot) {
                const minX = -roadWidth / 2 + sideMargin; 
                const maxX = roadWidth / 2 - sideMargin; 
                xPos = Math.random() * (maxX - minX) + minX;
                let tooClose = false;
                for (let px of chosenXPositions) {
                  if (Math.abs(xPos - px) < minCarSeparation) {
                    tooClose = true;
                    break;
                  }
                }
                if (!tooClose) {
                  foundSpot = true;
                  chosenXPositions.push(xPos);
                }
                attemptCount++;
              }
              if (foundSpot) {
                const randColor = colors[Math.floor(Math.random() * colors.length)];
                const parkedCar = createParkedCar(randColor);
                parkedCar.position.set(xPos, 0, z);
                scene.add(parkedCar);
                obstacles.push(parkedCar);
              }
            }
          }
        }
      },
      bridge: {
        length: 40, // Default bridge segment length.
        spawn: function(zStart, length) {
          // Spawn water below the bridge.
          const waterGeometry = new THREE.PlaneGeometry(roadWidth * 2, length);
          const waterMaterial = new THREE.MeshPhongMaterial({ color: 0x1e90ff });
          const waterPlane = new THREE.Mesh(waterGeometry, waterMaterial);
          waterPlane.rotation.x = -Math.PI / 2;
          waterPlane.position.z = zStart + length / 2;
          waterPlane.position.y = -0.1;
          scene.add(waterPlane);
          roadSegments.push(waterPlane);
          
          // Define the bridge: a narrow road over the water.
          const bridgeWidth = roadWidth / 5;
          const minX = -roadWidth/2 + bridgeWidth/2;
          const maxX = roadWidth/2 - bridgeWidth/2;
          const bridgeCenterX = Math.random() * (maxX - minX) + minX;
          
          const bridgeGeometry = new THREE.PlaneGeometry(bridgeWidth, length);
          const bridgeMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
          const bridge = new THREE.Mesh(bridgeGeometry, bridgeMaterial);
          bridge.rotation.x = -Math.PI / 2;
          bridge.position.set(bridgeCenterX, 0.01, zStart + length / 2);
          scene.add(bridge);
          bridge.userData.zStart = zStart;
          roadSegments.push(bridge);
          
          // Store bridge boundaries and segment length in userData.
          bridge.userData.isBridge = true;
          bridge.userData.bridgeXMin = bridgeCenterX - bridgeWidth/2;
          bridge.userData.bridgeXMax = bridgeCenterX + bridgeWidth/2;
          bridge.userData.segmentLength = length;
        }
      }
    };

    function rewindPlayerBehindBridge(seg) {
      // E.g. move the player 5 units behind the start of this bridge
      const behindDist = 5; // how many “seconds” or distance behind
      let behindZ = seg.userData.zStart - behindDist;
      if (behindZ < 0) behindZ = 0; // clamp so it won't go negative if near start

      // Re-center X to the safe region (the middle of the road/bridge)
      // or you can use seg.userData.bridgeXMin/Max if you want.
      player.position.x = (seg.userData.bridgeXMin + seg.userData.bridgeXMax)/2;
      player.position.z = behindZ;
    }

    // ----------------------
    // Unified function to spawn a segment chunk.
    // Determines segment type and length.
    // ----------------------
    function spawnChunk(zStart) {
      let segmentType;
      // First segment is always road; also prevent consecutive bridges.
      if (zStart === 0 || lastSegmentBridge) {
        segmentType = "road";
      } else {
        // 20% chance to spawn a bridge segment.
        segmentType = (Math.random() < 0.2) ? "bridge" : "road";
      }
      // Allow random variation in segment length (between 80% and 120% of default).
      let baseLength = segmentTypes[segmentType].length;
      let segmentLength = baseLength * (0.8 + Math.random() * 0.4);
      // Spawn the chosen segment.
      segmentTypes[segmentType].spawn(zStart, segmentLength);
      lastSegmentBridge = (segmentType === "bridge");
      spawnZ += segmentLength;
    }

    // ----------------------
    // Initialize the three.js scene and game objects
    // ----------------------
    function init() {
      // Remove any old renderer
      if (renderer && renderer.domElement) {
        document.body.removeChild(renderer.domElement);
      }
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB); // sky blue
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, -10);
      camera.lookAt(0, 0, 0);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      // Ensure the canvas is behind UI elements
      renderer.domElement.style.position = "absolute";
      renderer.domElement.style.zIndex = "0";
      document.body.appendChild(renderer.domElement);
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(0, 50, -50);
      scene.add(directionalLight);
      player = createCartoonCar(0x0000ff);
      player.position.set(0, 0, 0);
      scene.add(player);
      spawnZ = 0;
      obstacles = [];
      roadSegments = [];
      score = 0;
      gameOver = false;
      document.getElementById("gameOver").style.display = "none";
      document.getElementById("restartGameBtn").style.display = "none";
      // Reset the last segment flag on game start.
      lastSegmentBridge = false;
      spawnChunk(spawnZ);
      window.addEventListener('resize', onWindowResize, false);
      gameStartTime = performance.now();
      animate();
    }
    
    // ----------------------
    // Adjust camera and renderer on window resize
    // ----------------------
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function showScorePenalty(penalty) {
      const el = document.getElementById("scoreChange");
      el.textContent = penalty;    // e.g. "-10" or "-20"
      el.style.display = "block";
      
      // optional: fade out over 1 second
      let startTime = performance.now();
      let fadeInterval = setInterval(() => {
        let elapsed = performance.now() - startTime;
        if (elapsed > 1000) {
          clearInterval(fadeInterval);
          el.style.display = "none";
        } else {
          // we can gradually reduce opacity if we want
          let opacity = 1 - (elapsed / 1000);
          el.style.opacity = opacity;
        }
      }, 50);
    }

    function fallOffBridgeAndRespawn() {
      // Subtract points if you want:
      score -= 20;
      showPenaltyAboveCar("-20");    // if you have that logic
      updateScore();

      // Animate downward:
      let dropStartY = player.position.y;
      let dropDuration = 1000; // 1s
      let startTime = performance.now();

      let dropInterval = setInterval(() => {
        let elapsed = performance.now() - startTime;
        if (elapsed > dropDuration) {
          clearInterval(dropInterval);
          // Now re-position the car at the start of the bridge center
          // We'll figure out which bridge was last. Suppose "seg" is known:
          // For simplicity, let's pick the *last* bridge in roadSegments
          let lastBridge = roadSegments.find(r => r.userData && r.userData.isBridge);
          if (lastBridge) {
            let centerX = lastBridge.userData.bridgeCenterX;
            let startZ = lastBridge.userData.bridgeStartZ || 0;
            player.position.set(centerX, 0, startZ);
          }
        } else {
          // fraction 0..1
          let t = elapsed / dropDuration;
          // We can drop from y=0 to y=-5 for instance
          player.position.y = dropStartY - (5 * t);
        }
      }, 30);
    }

    function animateCrash(object) {
      const originalPos = object.position.clone();
      const shakeDuration = 300; // 0.3 sec for a quick shake
      const startTime = performance.now();
      let shakeInterval = setInterval(() => {
        let elapsed = performance.now() - startTime;
        if (elapsed > shakeDuration) {
          clearInterval(shakeInterval);
          object.position.copy(originalPos);
        } else {
          // random +/- 0.3 around original x,z
          object.position.x = originalPos.x + (Math.random() - 0.5) * 0.3;
          object.position.z = originalPos.z + (Math.random() - 0.5) * 0.3;
        }
      }, 30);
    }

    // ----------------------
    // Check for collisions with obstacles
    // ----------------------
    function checkCollisions() {
      const playerBox = new THREE.Box3().setFromObject(player);
      for (let obs of obstacles) {
        const obsBox = new THREE.Box3().setFromObject(obs);
        for (let i = obstacles.length - 1; i >= 0; i--) {
          const obsBox = new THREE.Box3().setFromObject(obstacles[i]);
          if (playerBox.intersectsBox(obsBox)) {
            penalty += 10;  // subtract penalty once
            showScorePenalty("-10");
            animateCrash(player);
            updateScore();

            // Remove obstacle so it won't collide again next frame:
            scene.remove(obstacles[i]);
            obstacles.splice(i, 1);

            // optionally break if you only want to register one collision per frame
            // break;
          }
        }
      }
      return false;
    }


    // ----------------------
    // Update score based on player's z position
    // ----------------------
    function updateScore() {
      score = Math.floor(player.position.z);
      effectiveScore = baseDistance - penalty;
      document.getElementById("score").textContent = "Score: " + effectiveScore;
    }
    
    function updateStopwatch() {
      // How many ms have elapsed since gameStartTime
      let elapsedMs = performance.now() - gameStartTime;
      // Convert to total seconds
      let totalSec = Math.floor(elapsedMs / 1000);
      // Calculate minutes & remainder seconds
      let minutes = Math.floor(totalSec / 60);
      let seconds = totalSec % 60;

      // Format "Time: M:SS"
      let secondsStr = (seconds < 10) ? ("0" + seconds) : seconds;
      document.getElementById("stopwatch").textContent =
        "Time: " + minutes + ":" + secondsStr;
    }

    // ----------------------
    // Update high score if needed
    // ----------------------
    function updateHighScore() {
      if (effectiveScore> highScore) {
        highScore = effectiveScore;
      }
      document.getElementById("highScore").textContent = "High Score: " + highScore;
    }
    
        // ----------------------
    // End the game
    // ----------------------
    function endGame() {
      console.log("Game Over")
      gameOver = true;
      cancelAnimationFrame(animationId);
      updateHighScore();

      // e.g. "Game Over – Final Score: 123"
      let finalText = "Game Over - Final Score: " + score;
      document.getElementById("gameOver").textContent = finalText;

      document.getElementById("gameOver").style.display = "block";
      document.getElementById("restartGameBtn").style.display = "block";
    }

    // ----------------------
    // Restart the game with a countdown
    // ----------------------
    function restartGame() {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      obstacles.forEach(o => scene.remove(o));
      roadSegments.forEach(r => scene.remove(r));
      scene.remove(player);
      obstacles = [];
      roadSegments = [];
      // Hide game over UI and trigger countdown before re‑initializing
      document.getElementById("gameOver").style.display = "none";
      document.getElementById("restartGameBtn").style.display = "none";
      startCountdown(init);
    }

    // ----------------------
    // The main animation loop
    // ----------------------
    function animate() {
      if (gameOver) return;
      animationId = requestAnimationFrame(animate);
      player.position.z += playerSpeed;
      baseDistance = Math.floor(player.position.z);
      const tiltInDegrees = currentTilt.x * (180 / Math.PI);
      player.position.x += tiltInDegrees * lateralSpeedFactor;
      // Clamp within the overall road boundaries.
      if (player.position.x < -roadWidth / 2) player.position.x = -roadWidth / 2;
      if (player.position.x > roadWidth / 2)  player.position.x = roadWidth / 2;
      
      camera.position.z = player.position.z - 10;
      camera.position.x = player.position.x;
      camera.lookAt(player.position.x, player.position.y, player.position.z);
      
      // If player is in a bridge segment, ensure they stay within its horizontal boundaries.
      for (let seg of roadSegments) {
        if (seg.userData.isBridge) {
          let segLength = seg.userData.segmentLength || segmentTypes.bridge.length;
          if (player.position.z > seg.position.z - segLength/2 && player.position.z < seg.position.z + segLength/2) {
            if (player.position.x < seg.userData.bridgeXMin || player.position.x > seg.userData.bridgeXMax) {
              // Car is out of X range
              if (!bridgePenaltyActive) {
                penalty += 20;
                showScorePenalty("-20");
                // Instead of falling animation, just reset position a few seconds behind
                rewindPlayerBehindBridge(seg);
                updateScore();
                bridgePenaltyActive = true;
              } 
              else {
                // Car is in X range => reset the flag so next time it goes out, penalty triggers again
                bridgePenaltyActive = false;
              }
            }
          }
        }
      }
    
      
      if (player.position.z + spawnDistance > spawnZ) {
        spawnChunk(spawnZ);
      }
      if (checkCollisions()) {
        updateScore();
      }
      updateScore();
      updateStopwatch();
      const elapsed = performance.now() - gameStartTime;
      if (elapsed >= gameDuration) {
        endGame();  // This calls your existing endGame() that shows "Game Over"
        return;
      }
      renderer.render(scene, camera);
    }


    // ----------------------
    // Countdown function before starting the game
    // ----------------------
    function startCountdown(callback) {
      const countdownEl = document.getElementById("countdown");
      let count = 3;
      countdownEl.style.display = "block";
      countdownEl.textContent = count;
      const interval = setInterval(() => {
        count--;
        if (count > 0) {
          countdownEl.textContent = count;
        } else {
          clearInterval(interval);
          countdownEl.textContent = "Go!";
          setTimeout(() => {
            countdownEl.style.display = "none";
            callback();
          }, 500);
        }
      }, 1000);
    }

    // ----------------------
    // WebSocket (IMU Data) Code
    // ----------------------
    let socket = null;
    document.getElementById("connectBtn").addEventListener("click", function() {
      const imuId = document.getElementById("imuIdInput").value.trim();
      if (!imuId) {
        alert("Please enter an IMU ID.");
        return;
      }
      const wsUrl = `wss://personal-site-oi5a.onrender.com/api/ws/imu/${imuId}/broadcast/`;
      console.log("Connecting to", wsUrl);
      if (socket) {
        socket.close();
      }
      socket = new WebSocket(wsUrl);
      socket.onopen = function(event) {
        console.log("Connected to:", wsUrl);
        document.getElementById("wsMessage").textContent = "Connected to: " + wsUrl;
      };
      socket.onmessage = function(event) {
        document.getElementById("wsMessage").textContent = event.data;
        try {
          const msg = JSON.parse(event.data);
          if (msg.data && msg.data.tilt) {
            currentTilt = msg.data.tilt;
          }
        } catch (e) {
          console.error("Error parsing message:", e);
        }
      };
      socket.onclose = function(event) {
        console.log("Disconnected from server");
        document.getElementById("wsMessage").textContent = "Disconnected from server";
      };
      socket.onerror = function(error) {
        console.error("WebSocket error:", error);
        document.getElementById("wsMessage").textContent = "WebSocket error. Check the console for details.";
      };
    });

    // ----------------------
    // Start Game on Button Click (with countdown)
    // ----------------------
    document.getElementById("startGameBtn").addEventListener("click", function() {
      const imuId = document.getElementById("imuIdInput").value.trim();
      if (!imuId) {
        alert("Please enter an IMU ID before starting the game.");
        return;
      }
      if (!socket || socket.readyState !== WebSocket.OPEN) {
        document.getElementById("connectBtn").click();
      }
      this.style.display = "none";
      startCountdown(init);
    });

    // Restart button click listener
    document.getElementById("restartGameBtn").addEventListener("click", function() {
      restartGame();
    });
    
    // ----------------------
    // Automatically connect if "id" query parameter is present
    // ----------------------
    (function() {
      const urlParams = new URLSearchParams(window.location.search);
      const autoImuId = urlParams.get('id');
      if (autoImuId) {
        document.getElementById("imuIdInput").value = autoImuId;
        document.getElementById("connectBtn").click();
      }
    })();
  </script>
</body>
</html>
