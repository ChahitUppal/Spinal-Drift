<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>IMU Game - Endless Runner (Car Version)</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #score {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 24px;
      z-index: 1;
    }
    #highScore {
      position: absolute;
      top: 40px;
      left: 10px;
      color: gold;
      font-size: 20px;
      z-index: 1;
    }
    #wsMessage {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 16px;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      z-index: 1;
      max-width: 80%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: red;
      font-size: 48px;
      display: none;
      z-index: 1;
    }
    #imuPanel {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.5);
      color: white;
      padding: 10px;
      z-index: 1;
    }
    #startGameBtn {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 18px;
      z-index: 1;
    }
    #restartGameBtn {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 18px;
      z-index: 1;
      display: none; /* Shown only when game is over */
    }
  </style>
  <!-- Include three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
  <!-- Score display -->
  <div id="score">Score: 0</div>
  <!-- High score display -->
  <div id="highScore">High Score: 0</div>
  <!-- Most recent WebSocket message display -->
  <div id="wsMessage">Latest Message: </div>
  <!-- Game Over message -->
  <div id="gameOver">Game Over</div>
  <!-- IMU connection panel -->
  <div id="imuPanel">
    <label for="imuIdInput">Enter IMU ID:</label>
    <input type="text" id="imuIdInput" placeholder="e.g., my_imu_id" />
    <button id="connectBtn">Connect</button>
  </div>
  <!-- Start Game button -->
  <button id="startGameBtn">Start Game</button>
  <!-- Restart Game button -->
  <button id="restartGameBtn">Restart</button>
  
  <script>
    // ----------------------
    // Three.js Game Variables
    // ----------------------
    let scene, camera, renderer;
    let player;                // The player's car (Group object)
    let obstacles = [];        // Array of obstacle (parked) cars
    let roadSegments = [];     // Array of road plane segments (including decorative lines)
    let gameOver = false;
    let score = 0;
    let highScore = 0;         // Track the user's best score across attempts

    // Movement / World logic
    const playerSpeed = 0.2;         // Constant forward movement speed
    const lateralSpeedFactor = 0.01; // Factor to convert tilt (in degrees) to lateral movement
    let currentTilt = { x: 0, y: 0, z: 0 }; // Latest IMU tilt values (in radians)
    let animationId; // To store the requestAnimationFrame ID

    // Infinite spawning logic
    let spawnZ = 0;            // How far we've spawned obstacles/road
    const chunkSize = 200;     // Distance for each chunk of road + obstacles
    const obstacleSpacing = 20;
    const roadWidth = 20;      // We'll make it narrower so lines are visible near the edges

    // For obstacle spacing logic
    // Minimum distance between parked cars on the same row
    const minCarSeparation = 2.0; 
    // Because the car is about 1 wide, let's define a margin so they don't go off the road
    const sideMargin = 1.0;

    // New lookahead distance for spawning chunks earlier
    const spawnDistance = 400;

    // ----------------------
    // Create a simple cartoon car for the player, oriented along +Z
    // ----------------------
    function createCartoonCar(color = 0x0000ff) {
      const carGroup = new THREE.Group();

      // Main body (width X=1, height Y=0.5, length Z=2)
      const bodyGeometry = new THREE.BoxGeometry(1, 0.5, 2);
      const bodyMaterial = new THREE.MeshPhongMaterial({ color });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.set(0, 0.25, 0);
      carGroup.add(body);

      // Cabin (width X=1, height Y=0.5, length Z=1)
      const cabinGeometry = new THREE.BoxGeometry(1, 0.5, 1);
      const cabinMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
      const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
      cabin.position.set(0, 0.75, 0);
      carGroup.add(cabin);

      // Wheels (four cylinders) â€“ axis along X
      const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.2, 12);
      const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
      
      // front wheels (forward in Z)
      const frontLeftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
      frontLeftWheel.rotation.x = Math.PI / 2; 
      frontLeftWheel.position.set(0.4, 0, 0.7);
      carGroup.add(frontLeftWheel);

      const frontRightWheel = frontLeftWheel.clone();
      frontRightWheel.position.set(-0.4, 0, 0.7);
      carGroup.add(frontRightWheel);

      // back wheels (backward in Z)
      const backLeftWheel = frontLeftWheel.clone();
      backLeftWheel.position.set(0.4, 0, -0.7);
      carGroup.add(backLeftWheel);

      const backRightWheel = frontLeftWheel.clone();
      backRightWheel.position.set(-0.4, 0, -0.7);
      carGroup.add(backRightWheel);

      return carGroup;
    }

    // ----------------------
    // Create a parked car obstacle, also oriented along +Z
    // ----------------------
    function createParkedCar(color = 0xff0000) {
      const carGroup = new THREE.Group();

      // Main body
      const bodyGeometry = new THREE.BoxGeometry(1, 0.5, 2);
      const bodyMaterial = new THREE.MeshPhongMaterial({ color });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.set(0, 0.25, 0);
      carGroup.add(body);

      // Cabin
      const cabinGeometry = new THREE.BoxGeometry(1, 0.5, 1);
      const cabinMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });
      const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
      cabin.position.set(0, 0.75, 0);
      carGroup.add(cabin);

      // Wheels
      const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.2, 12);
      const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });

      const frontLeftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
      frontLeftWheel.rotation.x = Math.PI / 2;
      frontLeftWheel.position.set(0.4, 0, 0.7);
      carGroup.add(frontLeftWheel);

      const frontRightWheel = frontLeftWheel.clone();
      frontRightWheel.position.set(-0.4, 0, 0.7);
      carGroup.add(frontRightWheel);

      const backLeftWheel = frontLeftWheel.clone();
      backLeftWheel.position.set(0.4, 0, -0.7);
      carGroup.add(backLeftWheel);

      const backRightWheel = frontLeftWheel.clone();
      backRightWheel.position.set(-0.4, 0, -0.7);
      carGroup.add(backRightWheel);

      return carGroup;
    }

    // ----------------------
    // Initialize the three.js scene and game objects
    // ----------------------
    function init() {
      // If there's an old renderer (from a previous game), remove it
      if (renderer && renderer.domElement) {
        document.body.removeChild(renderer.domElement);
      }

      // Create scene and set background color
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB); // sky blue

      // Create a perspective camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, -10);
      camera.lookAt(0, 0, 0);

      // Create renderer and add to the document
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(0, 50, -50);
      scene.add(directionalLight);

      // Create the player car
      player = createCartoonCar(0x0000ff);
      player.position.set(0, 0, 0);
      scene.add(player);

      // Reset infinite world parameters
      spawnZ = 0;
      obstacles = [];
      roadSegments = [];
      score = 0;
      gameOver = false;

      // Hide "Game Over" and "Restart" UI
      document.getElementById("gameOver").style.display = "none";
      document.getElementById("restartGameBtn").style.display = "none";

      // Spawn the first chunk
      spawnChunk(spawnZ);

      // Listen for window resize events
      window.addEventListener('resize', onWindowResize, false);

      // Start the animation loop
      animate();
    }

    // ----------------------
    // Spawn a "chunk" of road + obstacles from zStart to zStart + chunkSize
    // ----------------------
    function spawnChunk(zStart) {
      spawnRoadSegment(zStart);
      spawnRoadLines(zStart);
      spawnObstacles(zStart);
      spawnZ += chunkSize; // Next chunk should start after this
    }

    // Create a road segment (dark gray plane)
    function spawnRoadSegment(zStart) {
      const geometry = new THREE.PlaneGeometry(roadWidth, chunkSize);
      const material = new THREE.MeshPhongMaterial({ color: 0x444444 });
      const roadSegment = new THREE.Mesh(geometry, material);
      roadSegment.rotation.x = -Math.PI / 2;
      roadSegment.position.z = zStart + chunkSize / 2;
      scene.add(roadSegment);
      roadSegments.push(roadSegment);
    }

    // Create white/yellow lines on the road
    function spawnRoadLines(zStart) {
      // We'll do a dashed yellow center line, plus white boundary lines
      const dashLength = 2;  // each dash is length in the Z direction
      const dashSpace = 4;   // distance between dashes
      const dashCount = Math.floor(chunkSize / dashSpace);

      for (let i = 0; i < dashCount; i++) {
        const dashZ = zStart + i * dashSpace + dashSpace / 2;
        const dashGeom = new THREE.PlaneGeometry(0.2, dashLength);
        const dashMat = new THREE.MeshPhongMaterial({ color: 0xffff00 });
        const dash = new THREE.Mesh(dashGeom, dashMat);
        dash.rotation.x = -Math.PI / 2;
        dash.position.set(0, 0.01, dashZ);  // 0 in X, slight lift in Y
        scene.add(dash);
        roadSegments.push(dash);
      }

      // Left boundary line
      const leftLineGeom = new THREE.PlaneGeometry(0.1, chunkSize);
      const leftLineMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
      const leftLine = new THREE.Mesh(leftLineGeom, leftLineMat);
      leftLine.rotation.x = -Math.PI / 2;
      leftLine.position.set(-roadWidth / 2, 0.01, zStart + chunkSize / 2);
      scene.add(leftLine);
      roadSegments.push(leftLine);

      // Right boundary line
      const rightLine = leftLine.clone();
      rightLine.position.set(roadWidth / 2, 0.01, zStart + chunkSize / 2);
      scene.add(rightLine);
      roadSegments.push(rightLine);
    }

    // Generate obstacles within this chunk, spaced out by obstacleSpacing
    function spawnObstacles(zStart) {
      // A few sample colors for variety
      const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffffff, 0xffa500];
      
      for (let z = zStart + obstacleSpacing; z < zStart + chunkSize; z += obstacleSpacing) {
        // We'll place 2 or 3 cars per "row" 
        const obstacleCount = 2 + Math.floor(Math.random() * 2); // 2 or 3 obstacles
        // Keep track of the X positions chosen so far in this row
        const chosenXPositions = [];

        for (let i = 0; i < obstacleCount; i++) {
          let attemptCount = 0;
          let foundSpot = false;
          let xPos = 0;

          while (attemptCount < 10 && !foundSpot) {
            // Random X in a range that keeps them on the road
            const minX = -roadWidth / 2 + sideMargin; 
            const maxX =  roadWidth / 2 - sideMargin; 
            xPos = Math.random() * (maxX - minX) + minX;

            // Check against previously chosen positions
            let tooClose = false;
            for (let px of chosenXPositions) {
              if (Math.abs(xPos - px) < minCarSeparation) {
                tooClose = true;
                break;
              }
            }

            if (!tooClose) {
              foundSpot = true;
              chosenXPositions.push(xPos);
            }
            attemptCount++;
          }

          if (foundSpot) {
            const randColor = colors[Math.floor(Math.random() * colors.length)];
            const parkedCar = createParkedCar(randColor);
            parkedCar.position.set(xPos, 0, z);
            scene.add(parkedCar);
            obstacles.push(parkedCar);
          }
        }
      }
    }

    // Adjust camera and renderer on window resize
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Check collision between player and obstacles using bounding boxes
    function checkCollisions() {
      const playerBox = new THREE.Box3().setFromObject(player);
      for (let obs of obstacles) {
        const obsBox = new THREE.Box3().setFromObject(obs);
        if (playerBox.intersectsBox(obsBox)) {
          return true;
        }
      }
      return false;
    }

    // Update the score display based on player's z position
    function updateScore() {
      score = Math.floor(player.position.z);
      document.getElementById("score").textContent = "Score: " + score;
    }

    // Update the high score if the current score is higher
    function updateHighScore() {
      if (score > highScore) {
        highScore = score;
      }
      document.getElementById("highScore").textContent = "High Score: " + highScore;
    }

    // The main animation loop
    function animate() {
      if (gameOver) return;
      animationId = requestAnimationFrame(animate);

      // Constantly move the player forward along the z-axis
      player.position.z += playerSpeed;

      // Convert the current IMU tilt from radians to degrees
      const tiltInDegrees = currentTilt.x * (180 / Math.PI);
      // Use the tilt (in degrees) to adjust the player's x position
      player.position.x += tiltInDegrees * lateralSpeedFactor;

      // Keep the player within some horizontal bounds
      if (player.position.x < -roadWidth / 2) player.position.x = -roadWidth / 2;
      if (player.position.x > roadWidth / 2)  player.position.x =  roadWidth / 2;

      // Update camera position to follow the player
      camera.position.z = player.position.z - 10;
      camera.position.x = player.position.x;
      camera.lookAt(player.position.x, player.position.y, player.position.z);

      // If we're approaching the end of the current chunk, spawn another
      if (player.position.z + spawnDistance > spawnZ) {
        spawnChunk(spawnZ);
      }

      // Collision detection
      if (checkCollisions()) {
        endGame();
      }

      updateScore();
      renderer.render(scene, camera);
    }

    // End the game
    function endGame() {
      gameOver = true;
      cancelAnimationFrame(animationId);

      // Update and show high score
      updateHighScore();

      // Show game over UI
      document.getElementById("gameOver").style.display = "block";
      document.getElementById("restartGameBtn").style.display = "block";
    }

    // Restart the game by re-initializing everything
    function restartGame() {
      // Clear out old objects from the scene
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      obstacles.forEach(o => scene.remove(o));
      roadSegments.forEach(r => scene.remove(r));
      scene.remove(player);

      obstacles = [];
      roadSegments = [];

      init();
    }

    // ----------------------
    // WebSocket (IMU Data) Code
    // ----------------------
    let socket = null;
    document.getElementById("connectBtn").addEventListener("click", function() {
      const imuId = document.getElementById("imuIdInput").value.trim();
      if (!imuId) {
        alert("Please enter an IMU ID.");
        return;
      }

      // Example WS URL, change to your actual WebSocket server/endpoint
      const wsUrl = `wss://personal-site-oi5a.onrender.com/api/ws/imu/${imuId}/broadcast/`;
      console.log("Connecting to", wsUrl);

      // Close any existing connection before creating a new one
      if (socket) {
        socket.close();
      }

      socket = new WebSocket(wsUrl);

      socket.onopen = function(event) {
        console.log("Connected to:", wsUrl);
        document.getElementById("wsMessage").textContent = "Connected to: " + wsUrl;
      };

      socket.onmessage = function(event) {
        console.log("Message from server:", event.data);
        document.getElementById("wsMessage").textContent = event.data;

        try {
          const msg = JSON.parse(event.data);
          // Update current tilt values if available in the message (tilt values are in radians)
          if (msg.data && msg.data.tilt) {
            currentTilt = msg.data.tilt;
          }
        } catch (e) {
          console.error("Error parsing message:", e);
        }
      };

      socket.onclose = function(event) {
        console.log("Disconnected from server");
        document.getElementById("wsMessage").textContent = "Disconnected from server";
      };

      socket.onerror = function(error) {
        console.error("WebSocket error:", error);
        document.getElementById("wsMessage").textContent = "WebSocket error. Check the console for details.";
      };
    });

    // ----------------------
    // Start Game on Button Click (after ensuring an IMU ID is provided)
    // ----------------------
    document.getElementById("startGameBtn").addEventListener("click", function() {
      const imuId = document.getElementById("imuIdInput").value.trim();
      if (!imuId) {
        alert("Please enter an IMU ID before starting the game.");
        return;
      }
      // If not already connected, trigger the connect button click
      if (!socket || socket.readyState !== WebSocket.OPEN) {
        document.getElementById("connectBtn").click();
      }
      // Hide the Start Game button, then init
      this.style.display = "none";
      init();
    });

    // Restart button click listener
    document.getElementById("restartGameBtn").addEventListener("click", function() {
      restartGame();
    });
  </script>
</body>
</html>
