<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>IMU Game - Endless Runner (Car Version)</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #score {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 24px;
      z-index: 1;
    }
    #highScore {
      position: absolute;
      top: 40px;
      left: 10px;
      color: gold;
      font-size: 20px;
      z-index: 1;
    }
    #wsMessage {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 16px;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      z-index: 1;
      max-width: 80%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: red;
      font-size: 48px;
      display: none;
      z-index: 1;
    }
    /* Updated countdown style for better visibility */
    #countdown {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 72px;
      display: none;
      z-index: 1000;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 20px 40px;
      border-radius: 10px;
    }
    #imuPanel {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.5);
      color: white;
      padding: 10px;
      z-index: 1;
    }
    /* Player name panel style */
    #playerNamePanel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.5);
      color: white;
      padding: 10px;
      z-index: 1;
      font-size: 16px;
    }
    #startGameBtn {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 18px;
      z-index: 1;
    }
    #restartGameBtn {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 18px;
      z-index: 1;
      display: none; /* Shown only when game is over */
    }
  </style>
  <!-- Include three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
  <!-- Score display -->
  <div id="score">Score: 0</div>
  <!-- High score display -->
  <div id="highScore">High Score: 0</div>
  <!-- Most recent WebSocket message display -->
  <div id="wsMessage">Latest Message: </div>
  <!-- Game Over message -->
  <div id="gameOver">Game Over</div>
  <!-- Countdown display -->
  <div id="countdown"></div>
  <!-- Player Name panel -->
  <div id="playerNamePanel">
    <label for="playerNameInput">Player Name:</label>
    <input type="text" id="playerNameInput" placeholder="Enter player name" />
  </div>
  <!-- IMU connection panel -->
  <div id="imuPanel">
    <label for="imuIdInput">Enter IMU ID:</label>
    <input type="text" id="imuIdInput" placeholder="e.g., my_imu_id" />
    <button id="connectBtn">Connect</button>
  </div>
  <!-- Start Game button -->
  <button id="startGameBtn">Start Game</button>
  <!-- Restart Game button -->
  <button id="restartGameBtn">Restart</button>
  
  <script>
    // ----------------------
    // Global Game Variables
    // ----------------------
    let scene, camera, renderer;
    let player;                // The player's car (Group object)
    let obstacles = [];        // Array of obstacle (parked) cars
    let coins = [];            // Array of collectible coins
    let roadSegments = [];     // Array of segments (road, water, bridge, etc.)
    let gameOver = false;
    let score = 0;
    let coinBonus = 0;         // Bonus score from coins
    let highScore = 0;         // Track the user's best score across attempts

    // Global variable for player name
    let playerName = "";

    // Movement / World logic
    const basePlayerSpeed = 0.3; // Base forward movement speed
    var playerSpeed = basePlayerSpeed;      
    var speedPercent = 0.0;
    const lateralSpeedFactor = 0.01; // Factor to convert tilt (in degrees) to lateral movement

    const forwardTiltLowerBound = 10.0; // Absolute values less than this cause the car to move at full speed
    const forwardTiltUpperBound = 20.0; // Absolute values higher than this will cause the cars movement to stop

    let currentTilt = { x: 0, y: 0, z: 0 }; // Latest IMU tilt values (in radians)
    let animationId; // To store the requestAnimationFrame ID

    // Infinite spawning logic
    let spawnZ = 0;            // How far we've spawned obstacles/segments
    const spawnDistance = 400; // Lookahead distance for spawning chunks earlier

    // Obstacle and road settings
    const obstacleSpacing = 20;
    const roadWidth = 20;      // Overall road width
    const minCarSeparation = 2.0; 
    const sideMargin = 1.0;

    // Global flag to ensure no two consecutive bridge segments.
    let lastSegmentBridge = false;

    // ----------------------
    // Create a simple cartoon car for the player, oriented along +Z
    // ----------------------
    function createCartoonCar(color = 0x0000ff) {
      const carGroup = new THREE.Group();
      const bodyGeometry = new THREE.BoxGeometry(1, 0.5, 2);
      const bodyMaterial = new THREE.MeshPhongMaterial({ color });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.set(0, 0.25, 0);
      carGroup.add(body);
      const cabinGeometry = new THREE.BoxGeometry(1, 0.5, 1);
      const cabinMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
      const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
      cabin.position.set(0, 0.75, 0);
      carGroup.add(cabin);
      const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.2, 12);
      const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
      const frontLeftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
      frontLeftWheel.rotation.x = Math.PI / 2; 
      frontLeftWheel.position.set(0.4, 0, 0.7);
      carGroup.add(frontLeftWheel);
      const frontRightWheel = frontLeftWheel.clone();
      frontRightWheel.position.set(-0.4, 0, 0.7);
      carGroup.add(frontRightWheel);
      const backLeftWheel = frontLeftWheel.clone();
      backLeftWheel.position.set(0.4, 0, -0.7);
      carGroup.add(backLeftWheel);
      const backRightWheel = frontLeftWheel.clone();
      backRightWheel.position.set(-0.4, 0, -0.7);
      carGroup.add(backRightWheel);
      return carGroup;
    }

    // ----------------------
    // Create a parked car obstacle, also oriented along +Z
    // ----------------------
    function createParkedCar(color = 0xff0000) {
      const carGroup = new THREE.Group();
      const bodyGeometry = new THREE.BoxGeometry(1, 0.5, 2);
      const bodyMaterial = new THREE.MeshPhongMaterial({ color });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.set(0, 0.25, 0);
      carGroup.add(body);
      const cabinGeometry = new THREE.BoxGeometry(1, 0.5, 1);
      const cabinMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });
      const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
      cabin.position.set(0, 0.75, 0);
      carGroup.add(cabin);
      const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.2, 12);
      const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
      const frontLeftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
      frontLeftWheel.rotation.x = Math.PI / 2;
      frontLeftWheel.position.set(0.4, 0, 0.7);
      carGroup.add(frontLeftWheel);
      const frontRightWheel = frontLeftWheel.clone();
      frontRightWheel.position.set(-0.4, 0, 0.7);
      carGroup.add(frontRightWheel);
      const backLeftWheel = frontLeftWheel.clone();
      backLeftWheel.position.set(0.4, 0, -0.7);
      carGroup.add(backLeftWheel);
      const backRightWheel = frontLeftWheel.clone();
      backRightWheel.position.set(-0.4, 0, -0.7);
      carGroup.add(backRightWheel);
      return carGroup;
    }
    
    // ----------------------
    // Create a coin collectible
    // ----------------------
    function createCoin() {
      const coinGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 32);
      const coinMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00 });
      const coin = new THREE.Mesh(coinGeometry, coinMaterial);
      coin.rotation.x = Math.PI / 2; // Lay flat
      return coin;
    }

    // ----------------------
    // Segment definitions.
    // Each segment type defines a default length and a spawn() method that creates its objects.
    // ----------------------
    const segmentTypes = {
      straightRoad: {
        length: 50, // Default road segment length.
        spawn: function(zStart, length) {
          // Spawn the road surface.
          const geometry = new THREE.PlaneGeometry(roadWidth, length);
          const material = new THREE.MeshPhongMaterial({ color: 0x444444 });
          const road = new THREE.Mesh(geometry, material);
          road.rotation.x = -Math.PI / 2;
          road.position.z = zStart + length / 2;
          road.userData = {
            segmentType: "straightRoad",
            zStart: zStart,
            zEnd: zStart + length,
          }
          scene.add(road);
          roadSegments.push(road);

          // Spawn road lines (dashes).
          const dashLength = 2, dashSpace = 4;
          const dashCount = Math.floor(length / dashSpace);
          for (let i = 0; i < dashCount; i++) {
            const dashZ = zStart + i * dashSpace + dashSpace / 2;
            const dashGeom = new THREE.PlaneGeometry(0.2, dashLength);
            const dashMat = new THREE.MeshPhongMaterial({ color: 0xffff00 });
            const dash = new THREE.Mesh(dashGeom, dashMat);
            dash.rotation.x = -Math.PI / 2;
            dash.position.set(0, 0.01, dashZ);
            scene.add(dash);
            roadSegments.push(dash);
          }

          // Spawn left and right boundary lines.
          const leftLineGeom = new THREE.PlaneGeometry(0.1, length);
          const leftLineMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
          const leftLine = new THREE.Mesh(leftLineGeom, leftLineMat);
          leftLine.rotation.x = -Math.PI / 2;
          leftLine.position.set(-roadWidth / 2, 0.01, zStart + length / 2);
          scene.add(leftLine);
          roadSegments.push(leftLine);
          const rightLine = leftLine.clone();
          rightLine.position.set(roadWidth / 2, 0.01, zStart + length / 2);
          scene.add(rightLine);
          roadSegments.push(rightLine);

          // Spawn obstacles within this road segment.
          for (let z = zStart + obstacleSpacing; z < zStart + length; z += obstacleSpacing) {
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffffff, 0xffa500];
            const obstacleCount = 2 + Math.floor(Math.random() * 2);
            const chosenXPositions = [];
            for (let i = 0; i < obstacleCount; i++) {
              let attemptCount = 0, foundSpot = false, xPos = 0;
              while (attemptCount < 10 && !foundSpot) {
                const minX = -roadWidth / 2 + sideMargin; 
                const maxX = roadWidth / 2 - sideMargin; 
                xPos = Math.random() * (maxX - minX) + minX;
                let tooClose = false;
                for (let px of chosenXPositions) {
                  if (Math.abs(xPos - px) < minCarSeparation) {
                    tooClose = true;
                    break;
                  }
                }
                if (!tooClose) {
                  foundSpot = true;
                  chosenXPositions.push(xPos);
                }
                attemptCount++;
              }
              if (foundSpot) {
                const randColor = colors[Math.floor(Math.random() * colors.length)];
                const parkedCar = createParkedCar(randColor);
                parkedCar.position.set(xPos, 0, z);
                scene.add(parkedCar);
                obstacles.push(parkedCar);
              }
            }
          }
        },
        handleCollisions(data) {
          if (player.position.x < -roadWidth / 2) player.position.x = -roadWidth / 2;
          if (player.position.x >  roadWidth / 2) player.position.x =  roadWidth / 2;
        }
      },
      curvedRoad: {
        length: 100,
        spawn: function(zStart, length) {
          const wavePeriod = 1;
          const waveWidth = 1;
          const numPoints = 50;

          // Arrays to hold the left, right, and middle curve points
          const leftCurvePoints = [];
          const rightCurvePoints = [];
          const middleCurvePoints = [];

          for (let i = 0; i < numPoints; i++) {
            const t = i / (numPoints - 1);
            const z = zStart + t * length;
            const offsetX = (waveWidth * roadWidth * 0.5) * Math.sin(t * wavePeriod * 2 * Math.PI) 
                            - (waveWidth * roadWidth * 0.5);
            const y = 0.02;

            // Left edge
            leftCurvePoints.push(new THREE.Vector3(offsetX, y, z));
            // Right edge
            rightCurvePoints.push(new THREE.Vector3(offsetX + roadWidth, y, z));
            // Middle (for the dashed line)
            middleCurvePoints.push(new THREE.Vector3(offsetX + roadWidth * 0.5, y, z));
          }

          // ---------------------------------------------------
          // 1) Create a grey mesh that fills between left & right
          // ---------------------------------------------------
          // We'll create a triangle strip between leftCurvePoints and rightCurvePoints

          const roadGeometry = new THREE.BufferGeometry();
          const positions = [];

          // Build triangles between adjacent pairs
          for (let i = 0; i < numPoints - 1; i++) {
            const pA = leftCurvePoints[i];
            const pB = rightCurvePoints[i];
            const pC = leftCurvePoints[i+1];
            const pD = rightCurvePoints[i+1];

            // Triangle 1: pA -> pB -> pC
            positions.push(pA.x, pA.y, pA.z);
            positions.push(pB.x, pB.y, pB.z);
            positions.push(pC.x, pC.y, pC.z);

            // Triangle 2: pB -> pD -> pC
            positions.push(pB.x, pB.y, pB.z);
            positions.push(pD.x, pD.y, pD.z);
            positions.push(pC.x, pC.y, pC.z);
          }

          const positionAttribute = new THREE.Float32BufferAttribute(positions, 3);
          roadGeometry.setAttribute('position', positionAttribute);

          // Basic grey material
          const roadMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x808080, // grey
            side: THREE.DoubleSide 
          });
          const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);

          // ---------------------------------------------------
          // 2) Create dashed lines for left, right, and center
          // ---------------------------------------------------
          const leftGeometry = new THREE.BufferGeometry().setFromPoints(leftCurvePoints);
          const rightGeometry = new THREE.BufferGeometry().setFromPoints(rightCurvePoints);
          const middleGeometry = new THREE.BufferGeometry().setFromPoints(middleCurvePoints);

          // Use LineDashedMaterial for dashed lines
          const dashedMaterial = new THREE.LineDashedMaterial({
            color: 0xffff00,
            dashSize: 2,    // length of each dash
            gapSize: 1      // length of gap between dashes
          });

          const leftLine = new THREE.Line(leftGeometry, dashedMaterial);
          const rightLine = new THREE.Line(rightGeometry, dashedMaterial);

          // For the center line, you might want a white dashed line
          const centerDashedMaterial = new THREE.LineDashedMaterial({
            color: 0xffffff,
            dashSize: 2,
            gapSize: 1
          });
          const middleLine = new THREE.Line(middleGeometry, centerDashedMaterial);

          // Important: computeLineDistances() for dashed lines
          leftLine.computeLineDistances();
          rightLine.computeLineDistances();
          middleLine.computeLineDistances();

          // Attach userData so we can clamp X properly in animate()
          [leftLine, rightLine, middleLine].forEach(line => {
            line.userData = {
              segmentType: 'curvedRoad',
              zStart: zStart,
              zEnd: zStart + length,
              wavePeriod: wavePeriod,
              waveWidth: waveWidth,
              segmentLength: length
            };
          });

          // ---------------------------------------------------
          // Add everything to the scene in your preferred order
          // (Usually add mesh first, then lines on top)
          // ---------------------------------------------------
          scene.add(roadMesh);
          scene.add(leftLine);
          scene.add(rightLine);
          scene.add(middleLine);

          // Track your road segments if needed
          roadSegments.push(leftLine);
          roadSegments.push(rightLine);
          roadSegments.push(middleLine);
          
          // ---------------------------------------------------
          // 3) Spawn coins along the curved road middle line
          // ---------------------------------------------------
          for (let i = 0; i < numPoints; i++) {
            if (Math.random() < 0.3) { // 30% chance to spawn a coin at this point
              const coin = createCoin();
              coin.position.copy(middleCurvePoints[i]);
              coin.position.y += 0.5; // position coin slightly above the road
              scene.add(coin);
              coins.push(coin);
            }
          }
        },
        handleCollisions(data) {
          // Figure out param t for how far along the curve we are
          const segLength = data.segmentLength;
          const t = (player.position.z - data.zStart) / segLength;

          // The center X of the sine wave at this t
          const centerX =
            (data.waveWidth * roadWidth * 0.5)
            * Math.sin(t * data.wavePeriod * 2 * Math.PI);

          // Then clamp the player so that they stay within ±roadWidth/2 around centerX
          const minX = centerX - (roadWidth / 2);
          const maxX = centerX + (roadWidth / 2);

          if (player.position.x < minX) player.position.x = minX;
          if (player.position.x > maxX) player.position.x = maxX;
        }
      },
      bridge: {
        length: 40, // Default bridge segment length.
        spawn: function(zStart, length) {
          // Spawn water below the bridge.
          const waterGeometry = new THREE.PlaneGeometry(roadWidth * 2, length);
          const waterMaterial = new THREE.MeshPhongMaterial({ color: 0x1e90ff });
          const waterPlane = new THREE.Mesh(waterGeometry, waterMaterial);
          waterPlane.rotation.x = -Math.PI / 2;
          waterPlane.position.z = zStart + length / 2;
          waterPlane.position.y = -0.1;
          scene.add(waterPlane);
          roadSegments.push(waterPlane);
          
          // Define the bridge: a narrow road over the water.
          const bridgeWidth = roadWidth / 5;
          const minX = -roadWidth/2 + bridgeWidth/2;
          const maxX = roadWidth/2 - bridgeWidth/2;
          const bridgeCenterX = Math.random() * (maxX - minX) + minX;
          
          const bridgeGeometry = new THREE.PlaneGeometry(bridgeWidth, length);
          const bridgeMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
          const bridge = new THREE.Mesh(bridgeGeometry, bridgeMaterial);
          bridge.rotation.x = -Math.PI / 2;
          bridge.position.set(bridgeCenterX, 0.01, zStart + length / 2);
          
          scene.add(bridge);
          roadSegments.push(bridge);
          
          // Store bridge boundaries and segment length in userData.
          bridge.userData.segmentType = "bridge";
          bridge.userData.isBridge = true;
          bridge.userData.bridgeXMin = bridgeCenterX - bridgeWidth/2;
          bridge.userData.bridgeXMax = bridgeCenterX + bridgeWidth/2;
          bridge.userData.segmentLength = length;
          bridge.userData.zStart = zStart;
          bridge.userData.zEnd = zStart + length;
        },
        handleCollisions: function(data) {
          let segLength = data.segmentLength || segmentTypes.bridge.length;
          // If within Z-bounds, also check X-bounds
          if (player.position.x < data.bridgeXMin || player.position.x > data.bridgeXMax) {
            endGame();
            return;
          }
        }
      }
    };

    // ----------------------
    // Unified function to spawn a segment chunk.
    // Determines segment type and length.
    // ----------------------
    function spawnChunk(zStart) {
      let segmentType;
      // First segment is always road; also prevent consecutive bridges.
      if (zStart === 0 || lastSegmentBridge) {
        segmentType = "straightRoad";
      } else {
        const rand = Math.random();
        if (rand < 0.2) {
          segmentType = "bridge";
        } else if (rand < 0.5) {
          // This 0.5 cutoff means 20% for bridge (above) 
          // + 30% for curvedRoad (the difference between 0.5 and 0.2).
          segmentType = "curvedRoad";
        } else {
          segmentType = "straightRoad";
        }
      }
      // Allow random variation in segment length (between 80% and 120% of default).
      let baseLength = segmentTypes[segmentType].length;
      let segmentLength = baseLength * (0.8 + Math.random() * 0.4);
      // Spawn the chosen segment.
      segmentTypes[segmentType].spawn(zStart, segmentLength);
      lastSegmentBridge = (segmentType === "bridge");
      spawnZ += segmentLength;
    }

    // ----------------------
    // Initialize the three.js scene and game objects
    // ----------------------
    function init() {
      // Remove any old renderer
      if (renderer && renderer.domElement) {
        document.body.removeChild(renderer.domElement);
      }
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB); // sky blue
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, -10);
      camera.lookAt(0, 0, 0);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      // Ensure the canvas is behind UI elements
      renderer.domElement.style.position = "absolute";
      renderer.domElement.style.zIndex = "0";
      document.body.appendChild(renderer.domElement);
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(0, 50, -50);
      scene.add(directionalLight);
      player = createCartoonCar(0x0000ff);
      player.position.set(0, 0, 0);
      scene.add(player);
      spawnZ = 0;
      obstacles = [];
      roadSegments = [];
      coins = [];
      coinBonus = 0;
      score = 0;
      gameOver = false;
      document.getElementById("gameOver").style.display = "none";
      document.getElementById("restartGameBtn").style.display = "none";
      // Reset the last segment flag on game start.
      lastSegmentBridge = false;
      spawnChunk(spawnZ);
      window.addEventListener('resize', onWindowResize, false);
      animate();
    }

    // ----------------------
    // Adjust camera and renderer on window resize
    // ----------------------
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ----------------------
    // Check for collisions with obstacles
    // ----------------------
    function checkCollisions() {
      const playerBox = new THREE.Box3().setFromObject(player);
      for (let obs of obstacles) {
        const obsBox = new THREE.Box3().setFromObject(obs);
        if (playerBox.intersectsBox(obsBox)) {
          return true;
        }
      }
      return false;
    }

    // ----------------------
    // Update score based on player's z position and collected coins
    // ----------------------
    function updateScore() {
      score = Math.floor(player.position.z) + coinBonus;
      document.getElementById("score").textContent = "Score: " + score;
    }

    // ----------------------
    // Update high score if needed
    // ----------------------
    function updateHighScore() {
      if (score > highScore) {
        highScore = score;
      }
      document.getElementById("highScore").textContent = "High Score: " + highScore;
    }

    // ----------------------
    // The main animation loop
    // ----------------------
    function animate() {
      if (gameOver) return;
      animationId = requestAnimationFrame(animate);

      // Move player

      const absoluteForwardTiltInDegrees = Math.abs(currentTilt.y * (180 / Math.PI));

      if (absoluteForwardTiltInDegrees <= forwardTiltLowerBound) {
        speedPercent = 1.0
      } else if (absoluteForwardTiltInDegrees > forwardTiltUpperBound) {
        speedPercent = 0.0
      } else {
        const currDifference = Math.abs(absoluteForwardTiltInDegrees - forwardTiltUpperBound)
        speedPercent = currDifference / (forwardTiltUpperBound - forwardTiltLowerBound)
        console.log(speedPercent)
      }

      playerSpeed = basePlayerSpeed * speedPercent;

      player.position.z += playerSpeed;

      const tiltInDegrees = currentTilt.x * (180 / Math.PI);
      player.position.x += tiltInDegrees * lateralSpeedFactor * speedPercent;

      // 1) First, let the camera follow the player
      camera.position.z = player.position.z - 10;
      camera.position.x = player.position.x;
      camera.lookAt(player.position.x, player.position.y, player.position.z);
      
      // 2) Check for special segments (bridge, curvedRoad, etc.)
      for (let seg of roadSegments) {
        const data = seg.userData;
        if (!data) continue;
        
        // If the player is within the z-range of this segment...
        if (player.position.z >= data.zStart && player.position.z <= data.zEnd) {
          segmentTypes[data.segmentType].handleCollisions(data);
        }
      }

      // 3) Rotate coins and check for coin collection
      const playerBox = new THREE.Box3().setFromObject(player);
      for (let i = coins.length - 1; i >= 0; i--) {
        coins[i].rotation.y += 0.1;
        const coinBox = new THREE.Box3().setFromObject(coins[i]);
        if (playerBox.intersectsBox(coinBox)) {
          scene.remove(coins[i]);
          coins.splice(i, 1);
          coinBonus += 10;
        }
      }

      // 4) Spawn more road if needed
      if (player.position.z + spawnDistance > spawnZ) {
        spawnChunk(spawnZ);
      }

      // 5) Check collisions with obstacles
      if (checkCollisions()) {
        endGame();
      }

      // 6) Update score and render
      updateScore();
      renderer.render(scene, camera);
    }


    // ----------------------
    // End the game
    // ----------------------
    function endGame() {
      gameOver = true;
      cancelAnimationFrame(animationId);
      updateHighScore();
      document.getElementById("gameOver").style.display = "block";
      document.getElementById("restartGameBtn").style.display = "block";
    }

    // ----------------------
    // Restart the game with a countdown
    // ----------------------
    function restartGame() {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      obstacles.forEach(o => scene.remove(o));
      roadSegments.forEach(r => scene.remove(r));
      coins.forEach(c => scene.remove(c));
      scene.remove(player);
      obstacles = [];
      roadSegments = [];
      coins = [];
      coinBonus = 0;
      // Hide game over UI and trigger countdown before re‑initializing
      document.getElementById("gameOver").style.display = "none";
      document.getElementById("restartGameBtn").style.display = "none";
      startCountdown(init);
    }

    // ----------------------
    // Countdown function before starting the game
    // ----------------------
    function startCountdown(callback) {
      const countdownEl = document.getElementById("countdown");
      let count = 3;
      countdownEl.style.display = "block";
      countdownEl.textContent = count;
      const interval = setInterval(() => {
        count--;
        if (count > 0) {
          countdownEl.textContent = count;
        } else {
          clearInterval(interval);
          countdownEl.textContent = "Go!";
          setTimeout(() => {
            countdownEl.style.display = "none";
            callback();
          }, 500);
        }
      }, 1000);
    }

    // ----------------------
    // WebSocket (IMU Data) Code
    // ----------------------
    let socket = null;
    document.getElementById("connectBtn").addEventListener("click", function() {
      const imuId = document.getElementById("imuIdInput").value.trim();
      if (!imuId) {
        alert("Please enter an IMU ID.");
        return;
      }
      const wsUrl = `wss://personal-site-oi5a.onrender.com/api/ws/imu/${imuId}/broadcast/`;
      console.log("Connecting to", wsUrl);
      if (socket) {
        socket.close();
      }
      socket = new WebSocket(wsUrl);
      socket.onopen = function(event) {
        console.log("Connected to:", wsUrl);
        document.getElementById("wsMessage").textContent = "Connected to: " + wsUrl;
      };
      socket.onmessage = function(event) {
        document.getElementById("wsMessage").textContent = event.data;
        try {
          const msg = JSON.parse(event.data);
          if (msg.data && msg.data.tilt) {
            currentTilt = msg.data.tilt;
          }
        } catch (e) {
          console.error("Error parsing message:", e);
        }
      };
      socket.onclose = function(event) {
        console.log("Disconnected from server");
        document.getElementById("wsMessage").textContent = "Disconnected from server";
      };
      socket.onerror = function(error) {
        console.error("WebSocket error:", error);
        document.getElementById("wsMessage").textContent = "WebSocket error. Check the console for details.";
      };
    });

    // ----------------------
    // Start Game on Button Click (with countdown)
    // ----------------------
    document.getElementById("startGameBtn").addEventListener("click", function() {
      // Ensure player name is set
      const inputName = document.getElementById("playerNameInput").value.trim();
      if (!inputName) {
        alert("Please enter a player name before starting the game.");
        return;
      }
      playerName = inputName; // Save to global variable
      
      const imuId = document.getElementById("imuIdInput").value.trim();
      if (!imuId) {
        alert("Please enter an IMU ID before starting the game.");
        return;
      }
      if (!socket || socket.readyState !== WebSocket.OPEN) {
        document.getElementById("connectBtn").click();
      }
      this.style.display = "none";
      startCountdown(init);
    });

    // Restart button click listener
    document.getElementById("restartGameBtn").addEventListener("click", function() {
      restartGame();
    });
    
    // ----------------------
    // Automatically connect if "id" query parameter is present
    // ----------------------
    (function() {
      const urlParams = new URLSearchParams(window.location.search);
      const autoImuId = urlParams.get('id');
      if (autoImuId) {
        document.getElementById("imuIdInput").value = autoImuId;
        document.getElementById("connectBtn").click();
      }
    })();
  </script>
</body>
</html>
